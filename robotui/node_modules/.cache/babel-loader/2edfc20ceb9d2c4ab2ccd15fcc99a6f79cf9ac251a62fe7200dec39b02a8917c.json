{"ast":null,"code":"import _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\nvar declarationRegexp = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nvar propertiesRegexp = /[a-z_0-9]+/ig;\nvar pragmaMain = '#pragma main';\nvar parse = function parse(source) {\n  source = source.trim();\n  var pragmaMainIndex = source.indexOf(pragmaMain);\n  var mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;\n  var declaration = mainCode.match(declarationRegexp);\n  if (declaration !== null && declaration.length === 5) {\n    // tokenizer\n\n    var inputsCode = declaration[4];\n    var propsMatches = [];\n    var nameMatch = null;\n    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {\n      propsMatches.push(nameMatch);\n    }\n\n    // parser\n\n    var inputs = [];\n    var i = 0;\n    while (i < propsMatches.length) {\n      var isConst = propsMatches[i][0] === 'const';\n      if (isConst === true) {\n        i++;\n      }\n      var qualifier = propsMatches[i][0];\n      if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n        i++;\n      } else {\n        qualifier = '';\n      }\n      var _type = propsMatches[i++][0];\n      var count = Number.parseInt(propsMatches[i][0]);\n      if (Number.isNaN(count) === false) i++;else count = null;\n      var _name = propsMatches[i++][0];\n      inputs.push(new NodeFunctionInput(_type, _name, count, qualifier, isConst));\n    }\n\n    //\n\n    var blockCode = mainCode.substring(declaration[0].length);\n    var name = declaration[3] !== undefined ? declaration[3] : '';\n    var type = declaration[2];\n    var presicion = declaration[1] !== undefined ? declaration[1] : '';\n    var headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';\n    return {\n      type: type,\n      inputs: inputs,\n      name: name,\n      presicion: presicion,\n      inputsCode: inputsCode,\n      blockCode: blockCode,\n      headerCode: headerCode\n    };\n  } else {\n    throw new Error('FunctionNode: Function is not a GLSL code.');\n  }\n};\nvar GLSLNodeFunction = /*#__PURE__*/function (_NodeFunction) {\n  _inherits(GLSLNodeFunction, _NodeFunction);\n  var _super = _createSuper(GLSLNodeFunction);\n  function GLSLNodeFunction(source) {\n    var _this;\n    _classCallCheck(this, GLSLNodeFunction);\n    var _parse = parse(source),\n      type = _parse.type,\n      inputs = _parse.inputs,\n      name = _parse.name,\n      presicion = _parse.presicion,\n      inputsCode = _parse.inputsCode,\n      blockCode = _parse.blockCode,\n      headerCode = _parse.headerCode;\n    _this = _super.call(this, type, inputs, name, presicion);\n    _this.inputsCode = inputsCode;\n    _this.blockCode = blockCode;\n    _this.headerCode = headerCode;\n    return _this;\n  }\n  _createClass(GLSLNodeFunction, [{\n    key: \"getCode\",\n    value: function getCode() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;\n      var code;\n      var blockCode = this.blockCode;\n      if (blockCode !== '') {\n        var type = this.type,\n          inputsCode = this.inputsCode,\n          headerCode = this.headerCode,\n          presicion = this.presicion;\n        var declarationCode = \"\".concat(type, \" \").concat(name, \" ( \").concat(inputsCode.trim(), \" )\");\n        if (presicion !== '') {\n          declarationCode = \"\".concat(presicion, \" \").concat(declarationCode);\n        }\n        code = headerCode + declarationCode + blockCode;\n      } else {\n        // interface function\n\n        code = '';\n      }\n      return code;\n    }\n  }]);\n  return GLSLNodeFunction;\n}(NodeFunction);\nexport default GLSLNodeFunction;","map":{"version":3,"names":["NodeFunction","NodeFunctionInput","declarationRegexp","propertiesRegexp","pragmaMain","parse","source","trim","pragmaMainIndex","indexOf","mainCode","slice","length","declaration","match","inputsCode","propsMatches","nameMatch","exec","push","inputs","i","isConst","qualifier","type","count","Number","parseInt","isNaN","name","blockCode","substring","undefined","presicion","headerCode","Error","GLSLNodeFunction","_NodeFunction","_inherits","_super","_createSuper","_this","_classCallCheck","_parse","call","_createClass","key","value","getCode","arguments","code","declarationCode","concat"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js"],"sourcesContent":["import NodeFunction from '../core/NodeFunction.js';\nimport NodeFunctionInput from '../core/NodeFunctionInput.js';\n\nconst declarationRegexp = /^\\s*(highp|mediump|lowp)?\\s*([a-z_0-9]+)\\s*([a-z_0-9]+)?\\s*\\(([\\s\\S]*?)\\)/i;\nconst propertiesRegexp = /[a-z_0-9]+/ig;\n\nconst pragmaMain = '#pragma main';\n\nconst parse = ( source ) => {\n\n\tsource = source.trim();\n\n\tconst pragmaMainIndex = source.indexOf( pragmaMain );\n\n\tconst mainCode = pragmaMainIndex !== - 1 ? source.slice( pragmaMainIndex + pragmaMain.length ) : source;\n\n\tconst declaration = mainCode.match( declarationRegexp );\n\n\tif ( declaration !== null && declaration.length === 5 ) {\n\n\t\t// tokenizer\n\n\t\tconst inputsCode = declaration[ 4 ];\n\t\tconst propsMatches = [];\n\n\t\tlet nameMatch = null;\n\n\t\twhile ( ( nameMatch = propertiesRegexp.exec( inputsCode ) ) !== null ) {\n\n\t\t\tpropsMatches.push( nameMatch );\n\n\t\t}\n\n\t\t// parser\n\n\t\tconst inputs = [];\n\n\t\tlet i = 0;\n\n\t\twhile ( i < propsMatches.length ) {\n\n\t\t\tconst isConst = propsMatches[ i ][ 0 ] === 'const';\n\n\t\t\tif ( isConst === true ) {\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tlet qualifier = propsMatches[ i ][ 0 ];\n\n\t\t\tif ( qualifier === 'in' || qualifier === 'out' || qualifier === 'inout' ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = '';\n\n\t\t\t}\n\n\t\t\tconst type = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tlet count = Number.parseInt( propsMatches[ i ][ 0 ] );\n\n\t\t\tif ( Number.isNaN( count ) === false ) i ++;\n\t\t\telse count = null;\n\n\t\t\tconst name = propsMatches[ i ++ ][ 0 ];\n\n\t\t\tinputs.push( new NodeFunctionInput( type, name, count, qualifier, isConst ) );\n\n\t\t}\n\n\t\t//\n\n\t\tconst blockCode = mainCode.substring( declaration[ 0 ].length );\n\n\t\tconst name = declaration[ 3 ] !== undefined ? declaration[ 3 ] : '';\n\t\tconst type = declaration[ 2 ];\n\n\t\tconst presicion = declaration[ 1 ] !== undefined ? declaration[ 1 ] : '';\n\n\t\tconst headerCode = pragmaMainIndex !== - 1 ? source.slice( 0, pragmaMainIndex ) : '';\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tinputs,\n\t\t\tname,\n\t\t\tpresicion,\n\t\t\tinputsCode,\n\t\t\tblockCode,\n\t\t\theaderCode\n\t\t};\n\n\t} else {\n\n\t\tthrow new Error( 'FunctionNode: Function is not a GLSL code.' );\n\n\t}\n\n};\n\nclass GLSLNodeFunction extends NodeFunction {\n\n\tconstructor( source ) {\n\n\t\tconst { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse( source );\n\n\t\tsuper( type, inputs, name, presicion );\n\n\t\tthis.inputsCode = inputsCode;\n\t\tthis.blockCode = blockCode;\n\t\tthis.headerCode = headerCode;\n\n\t}\n\n\tgetCode( name = this.name ) {\n\n\t\tlet code;\n\n\t\tconst blockCode = this.blockCode;\n\n\t\tif ( blockCode !== '' ) {\n\n\t\t\tconst { type, inputsCode, headerCode, presicion } = this;\n\n\t\t\tlet declarationCode = `${ type } ${ name } ( ${ inputsCode.trim() } )`;\n\n\t\t\tif ( presicion !== '' ) {\n\n\t\t\t\tdeclarationCode = `${ presicion } ${ declarationCode }`;\n\n\t\t\t}\n\n\t\t\tcode = headerCode + declarationCode + blockCode;\n\n\t\t} else {\n\n\t\t\t// interface function\n\n\t\t\tcode = '';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n}\n\nexport default GLSLNodeFunction;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}