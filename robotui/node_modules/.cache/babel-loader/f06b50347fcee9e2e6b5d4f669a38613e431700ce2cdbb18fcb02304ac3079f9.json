{"ast":null,"code":"import _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { abs, mix, mod, dot, clamp, smoothstep } from '../math/MathNode.js';\nimport { tslFn, ShaderNode, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/LineMaterialNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\nimport { LineDashedMaterial } from 'three';\nvar defaultValues = new LineDashedMaterial();\nvar Line2NodeMaterial = /*#__PURE__*/function (_NodeMaterial) {\n  _inherits(Line2NodeMaterial, _NodeMaterial);\n  var _super = _createSuper(Line2NodeMaterial);\n  function Line2NodeMaterial() {\n    var _this;\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Line2NodeMaterial);\n    _this = _super.call(this);\n    _this.normals = false;\n    _this.lights = false;\n    _this.setDefaultValues(defaultValues);\n    _this.useAlphaToCoverage = true;\n    _this.useColor = params.vertexColors;\n    _this.useDash = params.dashed;\n    _this.useWorldUnits = false;\n    _this.dashOffset = 0;\n    _this.lineWidth = 1;\n    _this.lineColorNode = null;\n    _this.offsetNode = null;\n    _this.dashScaleNode = null;\n    _this.dashSizeNode = null;\n    _this.gapSizeNode = null;\n    _this.setupShaders();\n    _this.setValues(params);\n    return _this;\n  }\n  _createClass(Line2NodeMaterial, [{\n    key: \"setupShaders\",\n    value: function setupShaders() {\n      var _this2 = this;\n      var useAlphaToCoverage = this.alphaToCoverage;\n      var useColor = this.useColor;\n      var useDash = this.dashed;\n      var useWorldUnits = this.worldUnits;\n      var trimSegment = tslFn(function (_ref) {\n        var start = _ref.start,\n          end = _ref.end;\n        var a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column\n        var b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column\n        var nearEstimate = b.mul(-0.5).div(a);\n        var alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));\n        return vec4(mix(start.xyz, end.xyz, alpha), end.w);\n      });\n      this.vertexNode = new ShaderNode(function (stack) {\n        stack.assign(varying(vec2(), 'vUv'), uv());\n        var instanceStart = attribute('instanceStart');\n        var instanceEnd = attribute('instanceEnd');\n\n        // camera space\n\n        var start = property('vec4', 'start');\n        var end = property('vec4', 'end');\n        stack.assign(start, modelViewMatrix.mul(vec4(instanceStart, 1.0))); // force assignment into correct place in flow\n        stack.assign(end, modelViewMatrix.mul(vec4(instanceEnd, 1.0)));\n        if (useWorldUnits) {\n          stack.assign(varying(vec3(), 'worldStart'), start.xyz);\n          stack.assign(varying(vec3(), 'worldEnd'), end.xyz);\n        }\n        var aspect = viewport.z.div(viewport.w);\n\n        // special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n        // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n        // but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n        // perhaps there is a more elegant solution -- WestLangley\n\n        var perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column\n\n        stack.if(perspective, function (stack) {\n          stack.if(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), function (stack) {\n            stack.assign(end, trimSegment({\n              start: start,\n              end: end\n            }));\n          }).elseif(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), function (stack) {\n            stack.assign(start, trimSegment({\n              start: end,\n              end: start\n            }));\n          });\n        });\n\n        // clip space\n        var clipStart = cameraProjectionMatrix.mul(start);\n        var clipEnd = cameraProjectionMatrix.mul(end);\n\n        // ndc space\n        var ndcStart = clipStart.xyz.div(clipStart.w);\n        var ndcEnd = clipEnd.xyz.div(clipEnd.w);\n\n        // direction\n        var dir = ndcEnd.xy.sub(ndcStart.xy);\n\n        // account for clip-space aspect ratio\n        stack.assign(dir.x, dir.x.mul(aspect));\n        stack.assign(dir, dir.normalize());\n        var clip = temp(vec4());\n        if (useWorldUnits) {\n          // get the offset direction as perpendicular to the view vector\n          var worldDir = end.xyz.sub(start.xyz).normalize();\n          var offset = positionGeometry.y.lessThan(0.5).cond(start.xyz.cross(worldDir).normalize(), end.xyz.cross(worldDir).normalize());\n\n          // sign flip\n          stack.assign(offset, positionGeometry.x.lessThan(0.0).cond(offset.negate(), offset));\n          var forwardOffset = worldDir.dot(vec3(0.0, 0.0, 1.0));\n\n          // don't extend the line if we're rendering dashes because we\n          // won't be rendering the endcaps\n          if (!useDash) {\n            // extend the line bounds to encompass endcaps\n            stack.assign(start, start.sub(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));\n            stack.assign(end, end.add(vec4(worldDir.mul(materialLineWidth).mul(0.5), 0)));\n\n            // shift the position of the quad so it hugs the forward edge of the line\n            stack.assign(offset, offset.sub(vec3(dir.mul(forwardOffset), 0)));\n            stack.assign(offset.z, offset.z.add(0.5));\n          }\n\n          // endcaps\n\n          stack.if(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), function (stack) {\n            stack.assign(offset, offset.add(vec3(dir.mul(2.0).mul(forwardOffset), 0)));\n          });\n\n          // adjust for linewidth\n          stack.assign(offset, offset.mul(materialLineWidth).mul(0.5));\n\n          // set the world position\n\n          var worldPos = varying(vec4(), 'worldPos');\n          stack.assign(worldPos, positionGeometry.y.lessThan(0.5).cond(start, end));\n          stack.assign(worldPos, worldPos.add(vec4(offset, 0)));\n\n          // project the worldpos\n          stack.assign(clip, cameraProjectionMatrix.mul(worldPos));\n\n          // shift the depth of the projected points so the line\n          // segments overlap neatly\n          var clipPose = temp(vec3());\n          stack.assign(clipPose, positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));\n          stack.assign(clip.z, clipPose.z.mul(clip.w));\n        } else {\n          var _offset = property('vec2', 'offset');\n          stack.assign(_offset, vec2(dir.y, dir.x.negate()));\n\n          // undo aspect ratio adjustment\n          stack.assign(dir.x, dir.x.div(aspect));\n          stack.assign(_offset.x, _offset.x.div(aspect));\n\n          // sign flip\n          stack.assign(_offset, positionGeometry.x.lessThan(0.0).cond(_offset.negate(), _offset));\n\n          // endcaps\n          stack.if(positionGeometry.y.lessThan(0.0), function (stack) {\n            stack.assign(_offset, _offset.sub(dir));\n          }).elseif(positionGeometry.y.greaterThan(1.0), function (stack) {\n            stack.assign(_offset, _offset.add(dir));\n          });\n\n          // adjust for linewidth\n          stack.assign(_offset, _offset.mul(materialLineWidth));\n\n          // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n          stack.assign(_offset, _offset.div(viewport.w));\n\n          // select end\n          stack.assign(clip, positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));\n\n          // back to clip space\n          stack.assign(_offset, _offset.mul(clip.w));\n          stack.assign(clip, clip.add(vec4(_offset, 0, 0)));\n        }\n        return clip;\n      });\n      var closestLineToLine = tslFn(function (_ref2) {\n        var p1 = _ref2.p1,\n          p2 = _ref2.p2,\n          p3 = _ref2.p3,\n          p4 = _ref2.p4;\n        var p13 = p1.sub(p3);\n        var p43 = p4.sub(p3);\n        var p21 = p2.sub(p1);\n        var d1343 = dot(p13, p43);\n        var d4321 = dot(p43, p21);\n        var d1321 = dot(p13, p21);\n        var d4343 = dot(p43, p43);\n        var d2121 = dot(p21, p21);\n        var denom = d2121.mul(d4343).sub(d4321.mul(d4321));\n        var numer = d1343.mul(d4321).sub(d1321.mul(d4343));\n        var mua = clamp(numer.div(denom), 0, 1);\n        var mub = clamp(d1343.add(d4321.mul(mua)).div(d4343), 0, 1);\n        return vec2(mua, mub);\n      });\n      this.colorNode = new ShaderNode(function (stack) {\n        var vUv = varying(vec2(), 'vUv');\n        if (useDash) {\n          var offsetNode = _this2.offsetNode ? float(_this2.offsetNodeNode) : materialLineDashOffset;\n          var dashScaleNode = _this2.dashScaleNode ? float(_this2.dashScaleNode) : materialLineScale;\n          var dashSizeNode = _this2.dashSizeNode ? float(_this2.dashSizeNode) : materialLineDashSize;\n          var gapSizeNode = _this2.dashSizeNode ? float(_this2.dashGapNode) : materialLineGapSize;\n          stack.assign(dashSize, dashSizeNode);\n          stack.assign(gapSize, gapSizeNode);\n          var instanceDistanceStart = attribute('instanceDistanceStart');\n          var instanceDistanceEnd = attribute('instanceDistanceEnd');\n          var lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));\n          var vLineDistance = varying(lineDistance.add(materialLineDashOffset));\n          var vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;\n          stack.add(vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard()); // discard endcaps\n          stack.add(mod(vLineDistanceOffset, dashSize.add(gapSize)).greaterThan(dashSize).discard()); // todo - FIX\n        }\n\n        // force assignment into correct place in flow\n        var alpha = property('float', 'alpha');\n        stack.assign(alpha, 1);\n        if (useWorldUnits) {\n          var worldStart = varying(vec3(), 'worldStart');\n          var worldEnd = varying(vec3(), 'worldEnd');\n\n          // Find the closest points on the view ray and the line segment\n          var rayEnd = varying(vec4(), 'worldPos').xyz.normalize().mul(1e5);\n          var lineDir = worldEnd.sub(worldStart);\n          var params = closestLineToLine({\n            p1: worldStart,\n            p2: worldEnd,\n            p3: vec3(0.0, 0.0, 0.0),\n            p4: rayEnd\n          });\n          var p1 = worldStart.add(lineDir.mul(params.x));\n          var p2 = rayEnd.mul(params.y);\n          var delta = p1.sub(p2);\n          var len = delta.length();\n          var norm = len.div(materialLineWidth);\n          if (!useDash) {\n            if (useAlphaToCoverage) {\n              var dnorm = norm.fwidth();\n              stack.assign(alpha, smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());\n            } else {\n              stack.add(norm.greaterThan(0.5).discard());\n            }\n          }\n        } else {\n          // round endcaps\n\n          if (useAlphaToCoverage) {\n            var a = vUv.x;\n            var b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n            var len2 = a.mul(a).add(b.mul(b));\n\n            // force assignment out of following 'if' statement - to avoid uniform control flow errors\n            var dlen = property('float', 'dlen');\n            stack.assign(dlen, len2.fwidth());\n            stack.if(abs(vUv.y).greaterThan(1.0), function (stack) {\n              stack.assign(alpha, smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());\n            });\n          } else {\n            stack.if(abs(vUv.y).greaterThan(1.0), function (stack) {\n              var a = vUv.x;\n              var b = vUv.y.greaterThan(0.0).cond(vUv.y.sub(1.0), vUv.y.add(1.0));\n              var len2 = a.mul(a).add(b.mul(b));\n              stack.add(len2.greaterThan(1.0).discard());\n            });\n          }\n        }\n        var lineColorNode;\n        if (_this2.lineColorNode) {\n          lineColorNode = _this2.lineColorNode;\n        } else {\n          if (useColor) {\n            var instanceColorStart = attribute('instanceColorStart');\n            var instanceColorEnd = attribute('instanceColorEnd');\n            lineColorNode = varying(positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd));\n          } else {\n            lineColorNode = materialColor;\n          }\n        }\n        return vec4(lineColorNode, alpha);\n      });\n      this.needsUpdate = true;\n    }\n  }, {\n    key: \"worldUnits\",\n    get: function get() {\n      return this.useWorldUnits;\n    },\n    set: function set(value) {\n      if (this.useWorldUnits !== value) {\n        this.useWorldUnits = value;\n        this.setupShaders();\n      }\n    }\n  }, {\n    key: \"dashed\",\n    get: function get() {\n      return this.useDash;\n    },\n    set: function set(value) {\n      if (this.useDash !== value) {\n        this.useDash = value;\n        this.setupShaders();\n      }\n    }\n  }, {\n    key: \"alphaToCoverage\",\n    get: function get() {\n      return this.useAlphaToCoverage;\n    },\n    set: function set(value) {\n      if (this.useAlphaToCoverage !== value) {\n        this.useAlphaToCoverage = value;\n        this.setupShaders();\n      }\n    }\n  }]);\n  return Line2NodeMaterial;\n}(NodeMaterial);\nexport default Line2NodeMaterial;\naddNodeMaterial('Line2NodeMaterial', Line2NodeMaterial);","map":{"version":3,"names":["NodeMaterial","addNodeMaterial","temp","varying","property","attribute","cameraProjectionMatrix","materialColor","modelViewMatrix","positionGeometry","abs","mix","mod","dot","clamp","smoothstep","tslFn","ShaderNode","float","vec2","vec3","vec4","uv","materialLineScale","materialLineDashSize","materialLineGapSize","materialLineDashOffset","materialLineWidth","viewport","dashSize","gapSize","LineDashedMaterial","defaultValues","Line2NodeMaterial","_NodeMaterial","_inherits","_super","_createSuper","_this","params","arguments","length","undefined","_classCallCheck","call","normals","lights","setDefaultValues","useAlphaToCoverage","useColor","vertexColors","useDash","dashed","useWorldUnits","dashOffset","lineWidth","lineColorNode","offsetNode","dashScaleNode","dashSizeNode","gapSizeNode","setupShaders","setValues","_createClass","key","value","_this2","alphaToCoverage","worldUnits","trimSegment","_ref","start","end","a","element","b","nearEstimate","mul","div","alpha","sub","z","xyz","w","vertexNode","stack","assign","instanceStart","instanceEnd","aspect","perspective","equal","if","lessThan","and","greaterThan","elseif","greaterThanEqual","clipStart","clipEnd","ndcStart","ndcEnd","dir","xy","x","normalize","clip","worldDir","offset","y","cond","cross","negate","forwardOffset","add","or","worldPos","clipPose","closestLineToLine","_ref2","p1","p2","p3","p4","p13","p43","p21","d1343","d4321","d1321","d4343","d2121","denom","numer","mua","mub","colorNode","vUv","offsetNodeNode","dashGapNode","instanceDistanceStart","instanceDistanceEnd","lineDistance","vLineDistance","vLineDistanceOffset","discard","worldStart","worldEnd","rayEnd","lineDir","delta","len","norm","dnorm","fwidth","oneMinus","len2","dlen","instanceColorStart","instanceColorEnd","needsUpdate","get","set"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/materials/Line2NodeMaterial.js"],"sourcesContent":["import NodeMaterial, { addNodeMaterial } from './NodeMaterial.js';\nimport { temp } from '../core/VarNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { cameraProjectionMatrix } from '../accessors/CameraNode.js';\nimport { materialColor } from '../accessors/MaterialNode.js';\nimport { modelViewMatrix } from '../accessors/ModelNode.js';\nimport { positionGeometry } from '../accessors/PositionNode.js';\nimport { abs, mix, mod, dot, clamp, smoothstep } from '../math/MathNode.js';\nimport { tslFn, ShaderNode, float, vec2, vec3, vec4 } from '../shadernode/ShaderNode.js';\nimport { uv } from '../accessors/UVNode.js';\nimport { materialLineScale, materialLineDashSize, materialLineGapSize, materialLineDashOffset, materialLineWidth } from '../accessors/LineMaterialNode.js';\nimport { viewport } from '../display/ViewportNode.js';\nimport { dashSize, gapSize } from '../core/PropertyNode.js';\n\nimport { LineDashedMaterial } from 'three';\n\nconst defaultValues = new LineDashedMaterial();\n\nclass Line2NodeMaterial extends NodeMaterial {\n\n\tconstructor( params = {} ) {\n\n\t\tsuper();\n\n\t\tthis.normals = false;\n\t\tthis.lights = false;\n\n\t\tthis.setDefaultValues( defaultValues );\n\n\t\tthis.useAlphaToCoverage = true;\n\t\tthis.useColor = params.vertexColors;\n\t\tthis.useDash = params.dashed;\n\t\tthis.useWorldUnits = false;\n\n\t\tthis.dashOffset = 0;\n\t\tthis.lineWidth = 1;\n\n\t\tthis.lineColorNode = null;\n\n\t\tthis.offsetNode = null;\n\t\tthis.dashScaleNode = null;\n\t\tthis.dashSizeNode = null;\n\t\tthis.gapSizeNode = null;\n\n\t\tthis.setupShaders();\n\n\t\tthis.setValues( params );\n\n\t}\n\n\tsetupShaders() {\n\n\t\tconst useAlphaToCoverage = this.alphaToCoverage;\n\t\tconst useColor = this.useColor;\n\t\tconst useDash = this.dashed;\n\t\tconst useWorldUnits = this.worldUnits;\n\n\t\tconst trimSegment = tslFn( ( { start, end } ) => {\n\n\t\t\tconst a = cameraProjectionMatrix.element( 2 ).element( 2 ); // 3nd entry in 3th column\n\t\t\tconst b = cameraProjectionMatrix.element( 3 ).element( 2 ); // 3nd entry in 4th column\n\t\t\tconst nearEstimate = b.mul( -0.5 ).div( a );\n\n\t\t\tconst alpha = nearEstimate.sub( start.z ).div( end.z.sub( start.z ) );\n\n\t\t\treturn vec4( mix( start.xyz, end.xyz, alpha ), end.w );\n\n\t\t} );\n\n\t\tthis.vertexNode = new ShaderNode( ( stack ) => {\n\n\t\t\tstack.assign( varying( vec2(), 'vUv' ), uv() );\n\n\t\t\tconst instanceStart = attribute( 'instanceStart' );\n\t\t\tconst instanceEnd = attribute( 'instanceEnd' );\n\n\t\t\t// camera space\n\n\t\t\tconst start = property( 'vec4', 'start' );\n\t\t\tconst end = property( 'vec4', 'end' );\n\n\t\t\tstack.assign( start, modelViewMatrix.mul( vec4( instanceStart, 1.0 ) ) ); // force assignment into correct place in flow\n\t\t\tstack.assign( end, modelViewMatrix.mul( vec4( instanceEnd, 1.0 ) ) );\n\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\tstack.assign( varying( vec3(), 'worldStart' ), start.xyz );\n\t\t\t\tstack.assign( varying( vec3(), 'worldEnd' ), end.xyz );\n\n\t\t\t}\n\n\t\t\tconst aspect = viewport.z.div( viewport.w );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tconst perspective = cameraProjectionMatrix.element( 2 ).element( 3 ).equal( -1.0 ); // 4th entry in the 3rd column\n\n\t\t\tstack.if( perspective, ( stack ) => {\n\n\t\t\t\tstack.if( start.z.lessThan( 0.0 ).and( end.z.greaterThan( 0.0 ) ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( end, trimSegment( { start: start, end: end } ) );\n\n\t\t\t\t} ).elseif( end.z.lessThan( 0.0 ).and( start.z.greaterThanEqual( 0.0 ) ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( start, trimSegment( { start: end, end: start } ) );\n\n\t\t\t \t} );\n\n\t\t\t} );\n\n\t\t\t// clip space\n\t\t\tconst clipStart = cameraProjectionMatrix.mul( start );\n\t\t\tconst clipEnd = cameraProjectionMatrix.mul( end );\n\n\t\t\t// ndc space\n\t\t\tconst ndcStart = clipStart.xyz.div( clipStart.w );\n\t\t\tconst ndcEnd = clipEnd.xyz.div( clipEnd.w );\n\n\t\t\t// direction\n\t\t\tconst dir = ndcEnd.xy.sub( ndcStart.xy );\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tstack.assign( dir.x, dir.x.mul( aspect ) );\n\t\t\tstack.assign( dir, dir.normalize() );\n\n\t\t\tconst clip = temp( vec4() );\n\n\t\t\tif ( useWorldUnits ) {\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tconst worldDir = end.xyz.sub( start.xyz ).normalize();\n\n\t\t\t\tconst offset = positionGeometry.y.lessThan( 0.5 ).cond(\n\t\t\t\t\tstart.xyz.cross( worldDir ).normalize(),\n\t\t\t\t\tend.xyz.cross( worldDir ).normalize()\n\n\t\t\t\t);\n\n\t\t\t\t// sign flip\n\t\t\t\tstack.assign( offset, positionGeometry.x.lessThan( 0.0 ).cond( offset.negate(), offset ) );\n\n\t\t\t\tconst forwardOffset = worldDir.dot( vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\t// extend the line bounds to encompass endcaps\n\t\t\t\t\tstack.assign( start, start.sub( vec4( worldDir.mul( materialLineWidth ).mul( 0.5 ), 0 ) ) );\n\t\t\t\t\tstack.assign( end, end.add( vec4( worldDir.mul( materialLineWidth ).mul( 0.5 ), 0 ) ) );\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\tstack.assign( offset, offset.sub( vec3( dir.mul( forwardOffset ), 0 ) ) );\n\t\t\t\t\tstack.assign( offset.z, offset.z.add( 0.5 ) );\n\n\t\t\t\t}\n\n\t\t\t\t// endcaps\n\n\t\t\t\tstack.if( positionGeometry.y.greaterThan( 1.0 ).or( positionGeometry.y.lessThan( 0.0 ) ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( offset, offset.add( vec3( dir.mul( 2.0 ).mul( forwardOffset ), 0 ) ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\tstack.assign( offset, offset.mul( materialLineWidth ).mul( 0.5 ) );\n\n\t\t\t\t// set the world position\n\n\t\t\t\tconst worldPos = varying( vec4(), 'worldPos' );\n\n\t\t\t\tstack.assign( worldPos, positionGeometry.y.lessThan( 0.5 ).cond( start, end ) );\n\t\t\t\tstack.assign( worldPos, worldPos.add( vec4( offset, 0 ) ) );\n\n\t\t\t\t// project the worldpos\n\t\t\t\tstack.assign( clip, cameraProjectionMatrix.mul( worldPos ) );\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tconst clipPose = temp( vec3() );\n\n\t\t\t\tstack.assign( clipPose, positionGeometry.y.lessThan( 0.5 ).cond( ndcStart, ndcEnd ) );\n\t\t\t\tstack.assign( clip.z, clipPose.z.mul( clip.w ) );\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = property( 'vec2', 'offset' );\n\n\t\t\t\tstack.assign( offset, vec2( dir.y, dir.x.negate() ) );\n\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tstack.assign( dir.x, dir.x.div( aspect ) );\n\t\t\t\tstack.assign( offset.x, offset.x.div( aspect ) );\n\n\t\t\t\t// sign flip\n\t\t\t\tstack.assign( offset, positionGeometry.x.lessThan( 0.0 ).cond( offset.negate(), offset ) );\n\n\t\t\t\t// endcaps\n\t\t\t\tstack.if( positionGeometry.y.lessThan( 0.0 ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( offset, offset.sub( dir ) );\n\n\t\t\t\t} ).elseif( positionGeometry.y.greaterThan( 1.0 ), ( stack ) => {\n\n\t\t\t\t\tstack.assign( offset, offset.add( dir ) );\n\n\t\t\t\t} );\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\tstack.assign( offset, offset.mul( materialLineWidth ) );\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\tstack.assign( offset, offset.div( viewport.w ) );\n\n\t\t\t\t// select end\n\t\t\t\tstack.assign( clip, positionGeometry.y.lessThan( 0.5 ).cond( clipStart, clipEnd ) );\n\n\t\t\t\t// back to clip space\n\t\t\t\tstack.assign( offset, offset.mul( clip.w ) );\n\n\t\t\t\tstack.assign( clip, clip.add( vec4( offset, 0, 0 ) ) );\n\n\t\t\t}\n\n\t\t\treturn clip;\n\n\t\t} );\n\n\t\tconst closestLineToLine = tslFn( ( { p1, p2, p3, p4 } ) => {\n\n\t\t\tconst p13 = p1.sub( p3 );\n\t\t\tconst p43 = p4.sub( p3 );\n\n\t\t\tconst p21 = p2.sub( p1 );\n\n\t\t\tconst d1343 = dot( p13, p43 );\n\t\t\tconst d4321 = dot( p43, p21 );\n\t\t\tconst d1321 = dot( p13, p21 );\n\t\t\tconst d4343 = dot( p43, p43 );\n\t\t\tconst d2121 = dot( p21, p21 );\n\n\t\t\tconst denom = d2121.mul( d4343 ).sub( d4321.mul( d4321 ) );\n\t\t\tconst numer = d1343.mul( d4321 ).sub( d1321.mul( d4343 ) );\n\n\t\t\tconst mua = clamp( numer.div( denom ), 0, 1 );\n\t\t\tconst mub = clamp( d1343.add( d4321.mul( mua ) ).div( d4343 ), 0, 1 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t} );\n\n\t\tthis.colorNode = new ShaderNode( ( stack ) => {\n\n\t\t\tconst vUv = varying( vec2(), 'vUv' );\n\n\t\t\tif ( useDash ) {\n\n\t\t\t\tconst offsetNode = this.offsetNode ? float( this.offsetNodeNode ) : materialLineDashOffset;\n\t\t\t\tconst dashScaleNode = this.dashScaleNode ? float( this.dashScaleNode ) : materialLineScale;\n\t\t\t\tconst dashSizeNode = this.dashSizeNode ? float( this.dashSizeNode ) : materialLineDashSize;\n\t\t\t\tconst gapSizeNode = this.dashSizeNode ? float( this.dashGapNode ) : materialLineGapSize;\n\n\t\t\t\tstack.assign( dashSize, dashSizeNode );\n\t\t\t\tstack.assign( gapSize, gapSizeNode );\n\n\t\t\t\tconst instanceDistanceStart = attribute( 'instanceDistanceStart' );\n\t\t\t\tconst instanceDistanceEnd = attribute( 'instanceDistanceEnd' );\n\n\t\t\t\tconst lineDistance = positionGeometry.y.lessThan( 0.5 ).cond( dashScaleNode.mul( instanceDistanceStart ), materialLineScale.mul( instanceDistanceEnd ) );\n\n\t\t\t\tconst vLineDistance = varying( lineDistance.add( materialLineDashOffset ) );\n\t\t\t\tconst vLineDistanceOffset = offsetNode ? vLineDistance.add( offsetNode ) : vLineDistance;\n\n\t\t\t\tstack.add( vUv.y.lessThan( - 1.0 ).or( vUv.y.greaterThan( 1.0 ) ).discard() ); // discard endcaps\n\t\t\t\tstack.add( mod( vLineDistanceOffset, dashSize.add( gapSize ) ).greaterThan( dashSize ).discard() ); // todo - FIX\n\n\t\t\t}\n\n\t\t\t // force assignment into correct place in flow\n\t\t\tconst alpha = property( 'float', 'alpha' );\n\t\t\tstack.assign( alpha, 1 );\n\n\t\t\tif ( useWorldUnits ) {\n\n\n\t\t\t\tlet worldStart = varying( vec3(), 'worldStart' );\n\t\t\t\tlet worldEnd = varying( vec3(), 'worldEnd' );\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tconst rayEnd = varying( vec4(), 'worldPos' ).xyz.normalize().mul( 1e5 );\n\t\t\t\tconst lineDir = worldEnd.sub( worldStart );\n\t\t\t\tconst params = closestLineToLine( { p1: worldStart, p2: worldEnd, p3: vec3( 0.0, 0.0, 0.0 ), p4: rayEnd } );\n\n\t\t\t\tconst p1 = worldStart.add( lineDir.mul( params.x ) );\n\t\t\t\tconst p2 = rayEnd.mul( params.y );\n\t\t\t\tconst delta = p1.sub( p2 );\n\t\t\t\tconst len = delta.length();\n\t\t\t\tconst norm = len.div( materialLineWidth );\n\n\t\t\t\tif ( ! useDash ) {\n\n\t\t\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t\t\tconst dnorm = norm.fwidth();\n\t\t\t\t\t\tstack.assign( alpha, smoothstep( dnorm.negate().add( 0.5 ), dnorm.add( 0.5 ), norm ).oneMinus() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstack.add( norm.greaterThan( 0.5 ).discard() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// round endcaps\n\n\t\t\t\tif ( useAlphaToCoverage ) {\n\n\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).cond( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\n\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t// force assignment out of following 'if' statement - to avoid uniform control flow errors\n\t\t\t\t\tconst dlen = property( 'float', 'dlen' );\n\t\t\t\t\tstack.assign( dlen, len2.fwidth() );\n\n\t\t\t\t\tstack.if( abs( vUv.y ).greaterThan( 1.0 ), ( stack ) => {\n\n\t\t\t\t\t\tstack.assign( alpha, smoothstep( dlen.oneMinus(), dlen.add( 1 ), len2 ).oneMinus() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.if( abs( vUv.y ).greaterThan( 1.0 ), ( stack ) => {\n\n\t\t\t\t\t\tconst a = vUv.x;\n\t\t\t\t\t\tconst b = vUv.y.greaterThan( 0.0 ).cond( vUv.y.sub( 1.0 ), vUv.y.add( 1.0 ) );\n\t\t\t\t\t\tconst len2 = a.mul( a ).add( b.mul( b ) );\n\n\t\t\t\t\t\tstack.add( len2.greaterThan( 1.0 ).discard() );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet lineColorNode;\n\n\t\t\tif ( this.lineColorNode ) {\n\n\t\t\t\tlineColorNode = this.lineColorNode;\n\n\t\t\t} else {\n\n\t\t\t\tif ( useColor ) {\n\n\t\t\t\t\tconst instanceColorStart = attribute( 'instanceColorStart' );\n\t\t\t\t\tconst instanceColorEnd = attribute( 'instanceColorEnd' );\n\n\t\t\t\t\tlineColorNode = varying( positionGeometry.y.lessThan( 0.5 ).cond( instanceColorStart, instanceColorEnd ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlineColorNode = materialColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn vec4( lineColorNode, alpha );\n\n\t\t} );\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\n\tget worldUnits() {\n\n\t\treturn this.useWorldUnits;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( this.useWorldUnits !== value ) {\n\n\t\t\tthis.useWorldUnits = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n\n\tget dashed() {\n\n\t\treturn this.useDash;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( this.useDash !== value ) {\n\n\t\t\tthis.useDash = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n\n\tget alphaToCoverage() {\n\n\t\treturn this.useAlphaToCoverage;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( this.useAlphaToCoverage !== value ) {\n\n\t\t\tthis.useAlphaToCoverage = value;\n\t\t\tthis.setupShaders();\n\n\t\t}\n\n\t}\n\n}\n\nexport default Line2NodeMaterial;\n\naddNodeMaterial( 'Line2NodeMaterial', Line2NodeMaterial );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}