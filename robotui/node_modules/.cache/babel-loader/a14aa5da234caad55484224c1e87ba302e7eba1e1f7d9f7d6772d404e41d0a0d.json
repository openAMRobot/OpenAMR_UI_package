{"ast":null,"code":"import _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Node, { addNodeClass } from '../core/Node.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { normalize } from '../math/MathNode.js';\nimport { cameraViewMatrix } from './CameraNode.js';\nimport { modelNormalMatrix } from './ModelNode.js';\nimport { nodeImmutable } from '../shadernode/ShaderNode.js';\nvar NormalNode = /*#__PURE__*/function (_Node) {\n  _inherits(NormalNode, _Node);\n  var _super = _createSuper(NormalNode);\n  function NormalNode() {\n    var _this;\n    var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NormalNode.LOCAL;\n    _classCallCheck(this, NormalNode);\n    _this = _super.call(this, 'vec3');\n    _this.scope = scope;\n    return _this;\n  }\n  _createClass(NormalNode, [{\n    key: \"isGlobal\",\n    value: function isGlobal() {\n      return true;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash( /*builder*/\n    ) {\n      return \"normal-\".concat(this.scope);\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(builder) {\n      var scope = this.scope;\n      var outputNode = null;\n      if (scope === NormalNode.GEOMETRY) {\n        outputNode = attribute('normal', 'vec3');\n      } else if (scope === NormalNode.LOCAL) {\n        outputNode = varying(normalGeometry);\n      } else if (scope === NormalNode.VIEW) {\n        var vertexNode = modelNormalMatrix.mul(normalLocal);\n        outputNode = normalize(varying(vertexNode));\n      } else if (scope === NormalNode.WORLD) {\n        // To use inverseTransformDirection only inverse the param order like this: cameraViewMatrix.transformDirection( normalView )\n        var _vertexNode = normalView.transformDirection(cameraViewMatrix);\n        outputNode = normalize(varying(_vertexNode));\n      }\n      return outputNode.build(builder, this.getNodeType(builder));\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(data) {\n      _get(_getPrototypeOf(NormalNode.prototype), \"serialize\", this).call(this, data);\n      data.scope = this.scope;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data) {\n      _get(_getPrototypeOf(NormalNode.prototype), \"deserialize\", this).call(this, data);\n      this.scope = data.scope;\n    }\n  }]);\n  return NormalNode;\n}(Node);\nNormalNode.GEOMETRY = 'geometry';\nNormalNode.LOCAL = 'local';\nNormalNode.VIEW = 'view';\nNormalNode.WORLD = 'world';\nexport default NormalNode;\nexport var normalGeometry = nodeImmutable(NormalNode, NormalNode.GEOMETRY);\nexport var normalLocal = nodeImmutable(NormalNode, NormalNode.LOCAL);\nexport var normalView = nodeImmutable(NormalNode, NormalNode.VIEW);\nexport var normalWorld = nodeImmutable(NormalNode, NormalNode.WORLD);\nexport var transformedNormalView = property('vec3', 'TransformedNormalView');\nexport var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize();\nexport var transformedClearcoatNormalView = property('vec3', 'TransformedClearcoatNormalView');\naddNodeClass('NormalNode', NormalNode);","map":{"version":3,"names":["Node","addNodeClass","attribute","varying","property","normalize","cameraViewMatrix","modelNormalMatrix","nodeImmutable","NormalNode","_Node","_inherits","_super","_createSuper","_this","scope","arguments","length","undefined","LOCAL","_classCallCheck","call","_createClass","key","value","isGlobal","getHash","concat","generate","builder","outputNode","GEOMETRY","normalGeometry","VIEW","vertexNode","mul","normalLocal","WORLD","normalView","transformDirection","build","getNodeType","serialize","data","_get","_getPrototypeOf","prototype","deserialize","normalWorld","transformedNormalView","transformedNormalWorld","transformedClearcoatNormalView"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/accessors/NormalNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport { attribute } from '../core/AttributeNode.js';\nimport { varying } from '../core/VaryingNode.js';\nimport { property } from '../core/PropertyNode.js';\nimport { normalize } from '../math/MathNode.js';\nimport { cameraViewMatrix } from './CameraNode.js';\nimport { modelNormalMatrix } from './ModelNode.js';\nimport { nodeImmutable } from '../shadernode/ShaderNode.js';\n\nclass NormalNode extends Node {\n\n\tconstructor( scope = NormalNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tisGlobal() {\n\n\t\treturn true;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `normal-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === NormalNode.GEOMETRY ) {\n\n\t\t\toutputNode = attribute( 'normal', 'vec3' );\n\n\t\t} else if ( scope === NormalNode.LOCAL ) {\n\n\t\t\toutputNode = varying( normalGeometry );\n\n\t\t} else if ( scope === NormalNode.VIEW ) {\n\n\t\t\tconst vertexNode = modelNormalMatrix.mul( normalLocal );\n\t\t\toutputNode = normalize( varying( vertexNode ) );\n\n\t\t} else if ( scope === NormalNode.WORLD ) {\n\n\t\t\t// To use inverseTransformDirection only inverse the param order like this: cameraViewMatrix.transformDirection( normalView )\n\t\t\tconst vertexNode = normalView.transformDirection( cameraViewMatrix );\n\t\t\toutputNode = normalize( varying( vertexNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nNormalNode.GEOMETRY = 'geometry';\nNormalNode.LOCAL = 'local';\nNormalNode.VIEW = 'view';\nNormalNode.WORLD = 'world';\n\nexport default NormalNode;\n\nexport const normalGeometry = nodeImmutable( NormalNode, NormalNode.GEOMETRY );\nexport const normalLocal = nodeImmutable( NormalNode, NormalNode.LOCAL );\nexport const normalView = nodeImmutable( NormalNode, NormalNode.VIEW );\nexport const normalWorld = nodeImmutable( NormalNode, NormalNode.WORLD );\nexport const transformedNormalView = property( 'vec3', 'TransformedNormalView' );\nexport const transformedNormalWorld = transformedNormalView.transformDirection( cameraViewMatrix ).normalize();\nexport const transformedClearcoatNormalView = property( 'vec3', 'TransformedClearcoatNormalView' );\n\naddNodeClass( 'NormalNode', NormalNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}