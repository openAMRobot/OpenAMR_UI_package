{"ast":null,"code":"import _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/vec3 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\nvar depthMaterial = null;\nvar AnalyticLightNode = /*#__PURE__*/function (_LightingNode) {\n  _inherits(AnalyticLightNode, _LightingNode);\n  var _super = _createSuper(AnalyticLightNode);\n  function AnalyticLightNode() {\n    var _this;\n    var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, AnalyticLightNode);\n    _this = _super.call(this);\n    _this.updateType = NodeUpdateType.FRAME;\n    _this.light = light;\n    _this.rtt = null;\n    _this.shadowNode = null;\n    _this.color = new Color();\n    _this.colorNode = uniform(_this.color);\n    return _this;\n  }\n  _createClass(AnalyticLightNode, [{\n    key: \"getHash\",\n    value: function getHash( /*builder*/\n    ) {\n      return this.light.uuid;\n    }\n  }, {\n    key: \"setupShadow\",\n    value: function setupShadow(builder) {\n      var shadowNode = this.shadowNode;\n      if (shadowNode === null) {\n        if (depthMaterial === null) depthMaterial = builder.createNodeMaterial('MeshBasicNodeMaterial');\n        var shadow = this.light.shadow;\n        var rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);\n        var depthTexture = new DepthTexture();\n        depthTexture.minFilter = NearestFilter;\n        depthTexture.magFilter = NearestFilter;\n        depthTexture.image.width = shadow.mapSize.width;\n        depthTexture.image.height = shadow.mapSize.height;\n        depthTexture.compareFunction = LessCompare;\n        rtt.depthTexture = depthTexture;\n        shadow.camera.updateProjectionMatrix();\n\n        //\n\n        var bias = reference('bias', 'float', shadow);\n        var normalBias = reference('normalBias', 'float', shadow);\n        var shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));\n        shadowCoord = shadowCoord.xyz.div(shadowCoord.w);\n        var frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));\n        shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),\n        // WebGPU: Flip Y\n        shadowCoord.z.add(bias).mul(2).sub(1) // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n        );\n\n        var textureCompare = function textureCompare(depthTexture, shadowCoord, compare) {\n          return texture(depthTexture, shadowCoord).compare(compare);\n        };\n        //const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n        // BasicShadowMap\n\n        shadowNode = textureCompare(depthTexture, shadowCoord.xy, shadowCoord.z);\n\n        // PCFShadowMap\n        /*\n        const mapSize = reference( 'mapSize', 'vec2', shadow );\n        const radius = reference( 'radius', 'float', shadow );\n        \tconst texelSize = vec2( 1 ).div( mapSize );\n        const dx0 = texelSize.x.negate().mul( radius );\n        const dy0 = texelSize.y.negate().mul( radius );\n        const dx1 = texelSize.x.mul( radius );\n        const dy1 = texelSize.y.mul( radius );\n        const dx2 = dx0.mul( 2 );\n        const dy2 = dy0.mul( 2 );\n        const dx3 = dx1.mul( 2 );\n        const dy3 = dy1.mul( 2 );\n        \tshadowNode = add(\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n        \ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n        ).mul( 1 / 17 );\n        */\n        //\n\n        this.rtt = rtt;\n        this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode));\n        this.shadowNode = shadowNode;\n\n        //\n\n        this.updateBeforeType = NodeUpdateType.RENDER;\n      }\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(builder) {\n      if (this.light.castShadow) this.setupShadow(builder);\n    }\n  }, {\n    key: \"updateShadow\",\n    value: function updateShadow(frame) {\n      var rtt = this.rtt,\n        light = this.light;\n      var renderer = frame.renderer,\n        scene = frame.scene;\n      scene.overrideMaterial = depthMaterial;\n      rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);\n      light.shadow.updateMatrices(light);\n      renderer.setRenderTarget(rtt);\n      renderer.render(scene, light.shadow.camera);\n      renderer.setRenderTarget(null);\n      scene.overrideMaterial = null;\n    }\n  }, {\n    key: \"updateBefore\",\n    value: function updateBefore(frame) {\n      var light = this.light;\n      if (light.castShadow) this.updateShadow(frame);\n    }\n  }, {\n    key: \"update\",\n    value: function update( /*frame*/\n    ) {\n      var light = this.light;\n      this.color.copy(light.color).multiplyScalar(light.intensity);\n    }\n  }]);\n  return AnalyticLightNode;\n}(LightingNode);\nexport default AnalyticLightNode;\naddNodeClass('AnalyticLightNode', AnalyticLightNode);","map":{"version":3,"names":["LightingNode","NodeUpdateType","uniform","addNodeClass","vec3","reference","texture","positionWorld","normalWorld","Color","DepthTexture","NearestFilter","LessCompare","depthMaterial","AnalyticLightNode","_LightingNode","_inherits","_super","_createSuper","_this","light","arguments","length","undefined","_classCallCheck","call","updateType","FRAME","rtt","shadowNode","color","colorNode","_createClass","key","value","getHash","uuid","setupShadow","builder","createNodeMaterial","shadow","getRenderTarget","mapSize","width","height","depthTexture","minFilter","magFilter","image","compareFunction","camera","updateProjectionMatrix","bias","normalBias","shadowCoord","matrix","mul","add","xyz","div","w","frustumTest","x","greaterThanEqual","and","lessThanEqual","y","z","oneMinus","sub","textureCompare","compare","xy","mix","updateBeforeType","RENDER","setup","castShadow","updateShadow","frame","renderer","scene","overrideMaterial","setSize","updateMatrices","setRenderTarget","render","updateBefore","update","copy","multiplyScalar","intensity"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js"],"sourcesContent":["import LightingNode from './LightingNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\nimport { uniform } from '../core/UniformNode.js';\nimport { addNodeClass } from '../core/Node.js';\nimport { /*vec2,*/ vec3 } from '../shadernode/ShaderNode.js';\nimport { reference } from '../accessors/ReferenceNode.js';\nimport { texture } from '../accessors/TextureNode.js';\nimport { positionWorld } from '../accessors/PositionNode.js';\nimport { normalWorld } from '../accessors/NormalNode.js';\n//import { add } from '../math/OperatorNode.js';\n\nimport { Color, DepthTexture, NearestFilter, LessCompare } from 'three';\n\nlet depthMaterial = null;\n\nclass AnalyticLightNode extends LightingNode {\n\n\tconstructor( light = null ) {\n\n\t\tsuper();\n\n\t\tthis.updateType = NodeUpdateType.FRAME;\n\n\t\tthis.light = light;\n\n\t\tthis.rtt = null;\n\t\tthis.shadowNode = null;\n\n\t\tthis.color = new Color();\n\t\tthis.colorNode = uniform( this.color );\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.light.uuid;\n\n\t}\n\n\tsetupShadow( builder ) {\n\n\t\tlet shadowNode = this.shadowNode;\n\n\t\tif ( shadowNode === null ) {\n\n\t\t\tif ( depthMaterial === null ) depthMaterial = builder.createNodeMaterial( 'MeshBasicNodeMaterial' );\n\n\t\t\tconst shadow = this.light.shadow;\n\t\t\tconst rtt = builder.getRenderTarget( shadow.mapSize.width, shadow.mapSize.height );\n\n\t\t\tconst depthTexture = new DepthTexture();\n\t\t\tdepthTexture.minFilter = NearestFilter;\n\t\t\tdepthTexture.magFilter = NearestFilter;\n\t\t\tdepthTexture.image.width = shadow.mapSize.width;\n\t\t\tdepthTexture.image.height = shadow.mapSize.height;\n\t\t\tdepthTexture.compareFunction = LessCompare;\n\n\t\t\trtt.depthTexture = depthTexture;\n\n\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t//\n\n\t\t\tconst bias = reference( 'bias', 'float', shadow );\n\t\t\tconst normalBias = reference( 'normalBias', 'float', shadow );\n\n\t\t\tlet shadowCoord = uniform( shadow.matrix ).mul( positionWorld.add( normalWorld.mul( normalBias ) ) );\n\t\t\tshadowCoord = shadowCoord.xyz.div( shadowCoord.w );\n\n\t\t\tconst frustumTest = shadowCoord.x.greaterThanEqual( 0 )\n\t\t\t\t.and( shadowCoord.x.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.y.greaterThanEqual( 0 ) )\n\t\t\t\t.and( shadowCoord.y.lessThanEqual( 1 ) )\n\t\t\t\t.and( shadowCoord.z.lessThanEqual( 1 ) );\n\n\t\t\tshadowCoord = vec3(\n\t\t\t\tshadowCoord.x,\n\t\t\t\tshadowCoord.y.oneMinus(), // WebGPU: Flip Y\n\t\t\t\tshadowCoord.z.add( bias ).mul( 2 ).sub( 1 ) // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]\n\t\t\t);\n\n\t\t\tconst textureCompare = ( depthTexture, shadowCoord, compare ) => texture( depthTexture, shadowCoord ).compare( compare );\n\t\t\t//const textureCompare = ( depthTexture, shadowCoord, compare ) => compare.step( texture( depthTexture, shadowCoord ) );\n\n\t\t\t// BasicShadowMap\n\n\t\t\tshadowNode = textureCompare( depthTexture, shadowCoord.xy, shadowCoord.z );\n\n\t\t\t// PCFShadowMap\n\t\t\t/*\n\t\t\tconst mapSize = reference( 'mapSize', 'vec2', shadow );\n\t\t\tconst radius = reference( 'radius', 'float', shadow );\n\n\t\t\tconst texelSize = vec2( 1 ).div( mapSize );\n\t\t\tconst dx0 = texelSize.x.negate().mul( radius );\n\t\t\tconst dy0 = texelSize.y.negate().mul( radius );\n\t\t\tconst dx1 = texelSize.x.mul( radius );\n\t\t\tconst dy1 = texelSize.y.mul( radius );\n\t\t\tconst dx2 = dx0.mul( 2 );\n\t\t\tconst dy2 = dy0.mul( 2 );\n\t\t\tconst dx3 = dx1.mul( 2 );\n\t\t\tconst dy3 = dy1.mul( 2 );\n\n\t\t\tshadowNode = add(\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy2 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy, shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, 0 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx2, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx3, dy3 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( 0, dy1 ) ), shadowCoord.z ),\n\t\t\t\ttextureCompare( depthTexture, shadowCoord.xy.add( vec2( dx1, dy1 ) ), shadowCoord.z )\n\t\t\t).mul( 1 / 17 );\n\t\t\t*/\n\t\t\t//\n\n\t\t\tthis.rtt = rtt;\n\t\t\tthis.colorNode = this.colorNode.mul( frustumTest.mix( 1, shadowNode ) );\n\n\t\t\tthis.shadowNode = shadowNode;\n\n\t\t\t//\n\n\t\t\tthis.updateBeforeType = NodeUpdateType.RENDER;\n\n\t\t}\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tif ( this.light.castShadow ) this.setupShadow( builder );\n\n\t}\n\n\tupdateShadow( frame ) {\n\n\t\tconst { rtt, light } = this;\n\t\tconst { renderer, scene } = frame;\n\n\t\tscene.overrideMaterial = depthMaterial;\n\n\t\trtt.setSize( light.shadow.mapSize.width, light.shadow.mapSize.height );\n\n\t\tlight.shadow.updateMatrices( light );\n\n\t\trenderer.setRenderTarget( rtt );\n\t\trenderer.render( scene, light.shadow.camera );\n\t\trenderer.setRenderTarget( null );\n\n\t\tscene.overrideMaterial = null;\n\n\t}\n\n\tupdateBefore( frame ) {\n\n\t\tconst { light } = this;\n\n\t\tif ( light.castShadow ) this.updateShadow( frame );\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconst { light } = this;\n\n\t\tthis.color.copy( light.color ).multiplyScalar( light.intensity );\n\n\t}\n\n}\n\nexport default AnalyticLightNode;\n\naddNodeClass( 'AnalyticLightNode', AnalyticLightNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}