{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport { createNodeMaterialFromType } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\nimport { FloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform, ColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform } from '../../renderers/common/nodes/NodeUniform.js';\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\nimport { stack } from './StackNode.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\nvar typeFromLength = new Map([[2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);\nvar typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);\nvar isNonPaddingElementArray = new Set([Int32Array, Uint32Array, Float32Array]);\nvar toFloat = function toFloat(value) {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(object, renderer, parser) {\n    var scene = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var material = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    _classCallCheck(this, NodeBuilder);\n    this.object = object;\n    this.material = material || object && object.material || null;\n    this.geometry = object && object.geometry || null;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.scene = scene;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.updateBeforeNodes = [];\n    this.hashNodes = {};\n    this.lightsNode = null;\n    this.environmentNode = null;\n    this.fogNode = null;\n    this.toneMappingNode = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.computeShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: '',\n      compute: []\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.structs = {\n      vertex: [],\n      fragment: [],\n      compute: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindings = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.bindingsOffset = {\n      vertex: 0,\n      fragment: 0,\n      compute: 0\n    };\n    this.bindingsArray = null;\n    this.attributes = [];\n    this.bufferAttributes = [];\n    this.varyings = [];\n    this.vars = {\n      vertex: [],\n      fragment: [],\n      compute: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.chaining = [];\n    this.stack = stack();\n    this.tab = '\\t';\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: this.material,\n      getMIPLevelAlgorithmNode: function getMIPLevelAlgorithmNode(textureNode, levelNode) {\n        return levelNode.mul(maxMipLevel(textureNode));\n      }\n    };\n    this.cache = new NodeCache();\n    this.globalCache = this.cache;\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.buildStage = null;\n  }\n  _createClass(NodeBuilder, [{\n    key: \"getRenderTarget\",\n    value: function getRenderTarget(width, height, options) {\n      return new RenderTarget(width, height, options);\n    }\n  }, {\n    key: \"getCubeRenderTarget\",\n    value: function getCubeRenderTarget(size, options) {\n      return new CubeRenderTarget(size, options);\n    }\n  }, {\n    key: \"includes\",\n    value: function includes(node) {\n      return this.nodes.includes(node);\n    }\n  }, {\n    key: \"getBindings\",\n    value: function getBindings() {\n      var bindingsArray = this.bindingsArray;\n      if (bindingsArray === null) {\n        var bindings = this.bindings;\n        this.bindingsArray = bindingsArray = this.material !== null ? [].concat(_toConsumableArray(bindings.vertex), _toConsumableArray(bindings.fragment)) : bindings.compute;\n      }\n      return bindingsArray;\n    }\n  }, {\n    key: \"setHashNode\",\n    value: function setHashNode(node, hash) {\n      this.hashNodes[hash] = node;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (this.nodes.includes(node) === false) {\n        this.nodes.push(node);\n        this.setHashNode(node, node.getHash(this));\n      }\n    }\n  }, {\n    key: \"buildUpdateNodes\",\n    value: function buildUpdateNodes() {\n      var _iterator = _createForOfIteratorHelper(this.nodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var node = _step.value;\n          var updateType = node.getUpdateType();\n          var updateBeforeType = node.getUpdateBeforeType();\n          if (updateType !== NodeUpdateType.NONE) {\n            this.updateNodes.push(node.getSelf());\n          }\n          if (updateBeforeType !== NodeUpdateType.NONE) {\n            this.updateBeforeNodes.push(node);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"currentNode\",\n    get: function get() {\n      return this.chaining[this.chaining.length - 1];\n    }\n  }, {\n    key: \"addChain\",\n    value: function addChain(node) {\n      /*\n      if ( this.chaining.indexOf( node ) !== - 1 ) {\n      \t\tconsole.warn( 'Recursive node: ', node );\n      \t}\n      */\n\n      this.chaining.push(node);\n    }\n  }, {\n    key: \"removeChain\",\n    value: function removeChain(node) {\n      var lastChain = this.chaining.pop();\n      if (lastChain !== node) {\n        throw new Error('NodeBuilder: Invalid node chaining!');\n      }\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getNodeFromHash\",\n    value: function getNodeFromHash(hash) {\n      return this.hashNodes[hash];\n    }\n  }, {\n    key: \"addFlow\",\n    value: function addFlow(shaderStage, node) {\n      this.flowNodes[shaderStage].push(node);\n      return node;\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      this.context = context;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"setCache\",\n    value: function setCache(cache) {\n      this.cache = cache;\n    }\n  }, {\n    key: \"getCache\",\n    value: function getCache() {\n      return this.cache;\n    }\n  }, {\n    key: \"isAvailable\",\n    value: function isAvailable( /*name*/\n    ) {\n      return false;\n    }\n  }, {\n    key: \"getVertexIndex\",\n    value: function getVertexIndex() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getInstanceIndex\",\n    value: function getInstanceIndex() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getFrontFacing\",\n    value: function getFrontFacing() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getFragCoord\",\n    value: function getFragCoord() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"isFlipY\",\n    value: function isFlipY() {\n      return false;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture( /* texture, textureProperty, uvSnippet */\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getTextureLevel\",\n    value: function getTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */\n    ) {\n      console.warn('Abstract function.');\n    }\n\n    // @TODO: rename to .generateConst()\n  }, {\n    key: \"getConst\",\n    value: function getConst(type) {\n      var _this = this;\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (value === null) {\n        if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new Color();else if (type === 'vec2') value = new Vector2();else if (type === 'vec3') value = new Vector3();else if (type === 'vec4') value = new Vector4();\n      }\n      if (type === 'float') return toFloat(value);\n      if (type === 'int') return \"\".concat(Math.round(value));\n      if (type === 'uint') return value >= 0 ? \"\".concat(Math.round(value), \"u\") : '0u';\n      if (type === 'bool') return value ? 'true' : 'false';\n      if (type === 'color') return \"\".concat(this.getType('vec3'), \"( \").concat(toFloat(value.r), \", \").concat(toFloat(value.g), \", \").concat(toFloat(value.b), \" )\");\n      var typeLength = this.getTypeLength(type);\n      var componentType = this.getComponentType(type);\n      var getConst = function getConst(value) {\n        return _this.getConst(componentType, value);\n      };\n      if (typeLength === 2) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \" )\");\n      } else if (typeLength === 3) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \" )\");\n      } else if (typeLength === 4) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \", \").concat(getConst(value.w), \" )\");\n      } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {\n        return \"\".concat(this.getType(type), \"( \").concat(value.elements.map(getConst).join(', '), \" )\");\n      } else if (typeLength > 4) {\n        return \"\".concat(this.getType(type), \"()\");\n      }\n      throw new Error(\"NodeBuilder: Type '\".concat(type, \"' not found in generate constant attempt.\"));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      if (type === 'color') return 'vec3';\n      return type;\n    }\n  }, {\n    key: \"generateMethod\",\n    value: function generateMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"hasGeometryAttribute\",\n    value: function hasGeometryAttribute(name) {\n      return this.geometry && this.geometry.getAttribute(name) !== undefined;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name, type) {\n      var attributes = this.attributes;\n\n      // find attribute\n      var _iterator2 = _createForOfIteratorHelper(attributes),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _attribute = _step2.value;\n          if (_attribute.name === name) {\n            return _attribute;\n          }\n        }\n\n        // create a new if no exist\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var attribute = new NodeAttribute(name, type);\n      attributes.push(attribute);\n      return attribute;\n    }\n  }, {\n    key: \"getPropertyName\",\n    value: function getPropertyName(node /*, shaderStage*/) {\n      return node.name;\n    }\n  }, {\n    key: \"isVector\",\n    value: function isVector(type) {\n      return /vec\\d/.test(type);\n    }\n  }, {\n    key: \"isMatrix\",\n    value: function isMatrix(type) {\n      return /mat\\d/.test(type);\n    }\n  }, {\n    key: \"isReference\",\n    value: function isReference(type) {\n      return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n    }\n  }, {\n    key: \"needsColorSpaceToLinear\",\n    value: function needsColorSpaceToLinear( /*texture*/\n    ) {\n      return false;\n    }\n\n    /** @deprecated, r152 */\n  }, {\n    key: \"getTextureEncodingFromMap\",\n    value: function getTextureEncodingFromMap(map) {\n      console.warn('THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.');\n      return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n    }\n  }, {\n    key: \"getTextureColorSpaceFromMap\",\n    value: function getTextureColorSpaceFromMap(map) {\n      var colorSpace;\n      if (map && map.isTexture) {\n        colorSpace = map.colorSpace;\n      } else if (map && map.isWebGLRenderTarget) {\n        colorSpace = map.texture.colorSpace;\n      } else {\n        colorSpace = NoColorSpace;\n      }\n      return colorSpace;\n    }\n  }, {\n    key: \"getComponentType\",\n    value: function getComponentType(type) {\n      type = this.getVectorType(type);\n      if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;\n      var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n      if (componentType === null) return null;\n      if (componentType[1] === 'b') return 'bool';\n      if (componentType[1] === 'i') return 'int';\n      if (componentType[1] === 'u') return 'uint';\n      return 'float';\n    }\n  }, {\n    key: \"getVectorType\",\n    value: function getVectorType(type) {\n      if (type === 'color') return 'vec3';\n      if (type === 'texture') return 'vec4';\n      return type;\n    }\n  }, {\n    key: \"getTypeFromLength\",\n    value: function getTypeFromLength(length) {\n      var componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';\n      if (length === 1) return componentType;\n      var baseType = typeFromLength.get(length);\n      var prefix = componentType === 'float' ? '' : componentType[0];\n      return prefix + baseType;\n    }\n  }, {\n    key: \"getTypeFromArray\",\n    value: function getTypeFromArray(array) {\n      return typeFromArray.get(array.constructor);\n    }\n  }, {\n    key: \"getTypeFromAttribute\",\n    value: function getTypeFromAttribute(attribute) {\n      var dataAttribute = attribute;\n      if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;\n      var array = dataAttribute.array;\n      var itemSize = isNonPaddingElementArray.has(array.constructor) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;\n      var normalized = attribute.normalized;\n      var arrayType;\n      if (!(attribute instanceof Float16BufferAttribute) && normalized !== true) {\n        arrayType = this.getTypeFromArray(array);\n      }\n      return this.getTypeFromLength(itemSize, arrayType);\n    }\n  }, {\n    key: \"getTypeLength\",\n    value: function getTypeLength(type) {\n      var vecType = this.getVectorType(type);\n      var vecNum = /vec([2-4])/.exec(vecType);\n      if (vecNum !== null) return Number(vecNum[1]);\n      if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n      if (/mat3/.test(type) === true) return 9;\n      if (/mat4/.test(type) === true) return 16;\n      return 0;\n    }\n  }, {\n    key: \"getVectorFromMatrix\",\n    value: function getVectorFromMatrix(type) {\n      return type.replace('mat', 'vec');\n    }\n  }, {\n    key: \"changeComponentType\",\n    value: function changeComponentType(type, newComponentType) {\n      return this.getTypeFromLength(this.getTypeLength(type), newComponentType);\n    }\n  }, {\n    key: \"getIntegerType\",\n    value: function getIntegerType(type) {\n      var componentType = this.getComponentType(type);\n      if (componentType === 'int' || componentType === 'uint') return type;\n      return this.changeComponentType(type, 'int');\n    }\n  }, {\n    key: \"addStack\",\n    value: function addStack() {\n      this.stack = stack(this.stack);\n      return this.stack;\n    }\n  }, {\n    key: \"removeStack\",\n    value: function removeStack() {\n      var currentStack = this.stack;\n      this.stack = currentStack.parent;\n      return currentStack;\n    }\n  }, {\n    key: \"getDataFromNode\",\n    value: function getDataFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var cache = node.isGlobal(this) ? this.globalCache : this.cache;\n      var nodeData = cache.getNodeData(node);\n      if (nodeData === undefined) {\n        nodeData = {};\n        cache.setNodeData(node, nodeData);\n      }\n      if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};\n      return nodeData[shaderStage];\n    }\n  }, {\n    key: \"getNodeProperties\",\n    value: function getNodeProperties(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      return nodeData.properties || (nodeData.properties = {\n        outputNode: null\n      });\n    }\n  }, {\n    key: \"getBufferAttributeFromNode\",\n    value: function getBufferAttributeFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node);\n      var bufferAttribute = nodeData.bufferAttribute;\n      if (bufferAttribute === undefined) {\n        var index = this.uniforms.index++;\n        bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);\n        this.bufferAttributes.push(bufferAttribute);\n        nodeData.bufferAttribute = bufferAttribute;\n      }\n      return bufferAttribute;\n    }\n  }, {\n    key: \"getStructTypeFromNode\",\n    value: function getStructTypeFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeStruct = nodeData.structType;\n      if (nodeStruct === undefined) {\n        var index = this.structs.index++;\n        node.name = \"StructType\".concat(index);\n        this.structs[shaderStage].push(node);\n        nodeData.structType = node;\n      }\n      return node;\n    }\n  }, {\n    key: \"getUniformFromNode\",\n    value: function getUniformFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeUniform = nodeData.uniform;\n      if (nodeUniform === undefined) {\n        var index = this.uniforms.index++;\n        nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);\n        this.uniforms[shaderStage].push(nodeUniform);\n        nodeData.uniform = nodeUniform;\n      }\n      return nodeUniform;\n    }\n  }, {\n    key: \"getVarFromNode\",\n    value: function getVarFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeVar = nodeData.variable;\n      if (nodeVar === undefined) {\n        var vars = this.vars[shaderStage];\n        var index = vars.length;\n        nodeVar = new NodeVar('nodeVar' + index, type);\n        vars.push(nodeVar);\n        nodeData.variable = nodeVar;\n      }\n      return nodeVar;\n    }\n  }, {\n    key: \"getVaryingFromNode\",\n    value: function getVaryingFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node, 'any');\n      var nodeVarying = nodeData.varying;\n      if (nodeVarying === undefined) {\n        var varyings = this.varyings;\n        var index = varyings.length;\n        nodeVarying = new NodeVarying('nodeVarying' + index, type);\n        varyings.push(nodeVarying);\n        nodeData.varying = nodeVarying;\n      }\n      return nodeVarying;\n    }\n  }, {\n    key: \"getCodeFromNode\",\n    value: function getCodeFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node);\n      var nodeCode = nodeData.code;\n      if (nodeCode === undefined) {\n        var codes = this.codes[shaderStage];\n        var index = codes.length;\n        nodeCode = new NodeCode('nodeCode' + index, type);\n        codes.push(nodeCode);\n        nodeData.code = nodeCode;\n      }\n      return nodeCode;\n    }\n  }, {\n    key: \"addLineFlowCode\",\n    value: function addLineFlowCode(code) {\n      if (code === '') return this;\n      code = this.tab + code;\n      if (!/;\\s*$/.test(code)) {\n        code = code + ';\\n';\n      }\n      this.flow.code += code;\n      return this;\n    }\n  }, {\n    key: \"addFlowCode\",\n    value: function addFlowCode(code) {\n      this.flow.code += code;\n      return this;\n    }\n  }, {\n    key: \"addFlowTab\",\n    value: function addFlowTab() {\n      this.tab += '\\t';\n      return this;\n    }\n  }, {\n    key: \"removeFlowTab\",\n    value: function removeFlowTab() {\n      this.tab = this.tab.slice(0, -1);\n      return this;\n    }\n  }, {\n    key: \"getFlowData\",\n    value: function getFlowData(node /*, shaderStage*/) {\n      return this.flowsData.get(node);\n    }\n  }, {\n    key: \"flowNode\",\n    value: function flowNode(node) {\n      var output = node.getNodeType(this);\n      var flowData = this.flowChildNode(node, output);\n      this.flowsData.set(node, flowData);\n      return flowData;\n    }\n  }, {\n    key: \"flowChildNode\",\n    value: function flowChildNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      flow.result = node.build(this, output);\n      this.flow = previousFlow;\n      return flow;\n    }\n  }, {\n    key: \"flowNodeFromShaderStage\",\n    value: function flowNodeFromShaderStage(shaderStage, node) {\n      var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var previousShaderStage = this.shaderStage;\n      this.setShaderStage(shaderStage);\n      var flowData = this.flowChildNode(node, output);\n      if (propertyName !== null) {\n        flowData.code += \"\".concat(this.tab + propertyName, \" = \").concat(flowData.result, \";\\n\");\n      }\n      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n      this.setShaderStage(previousShaderStage);\n      return flowData;\n    }\n  }, {\n    key: \"getAttributesArray\",\n    value: function getAttributesArray() {\n      return this.attributes.concat(this.bufferAttributes);\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes( /*shaderStage*/\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVaryings\",\n    value: function getVaryings( /*shaderStage*/\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVar\",\n    value: function getVar(type, name) {\n      return \"\".concat(this.getType(type), \" \").concat(name);\n    }\n  }, {\n    key: \"getVars\",\n    value: function getVars(shaderStage) {\n      var snippet = '';\n      var vars = this.vars[shaderStage];\n      var _iterator3 = _createForOfIteratorHelper(vars),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var variable = _step3.value;\n          snippet += \"\".concat(this.getVar(variable.type, variable.name), \"; \");\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return snippet;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms( /*shaderStage*/\n    ) {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCodes\",\n    value: function getCodes(shaderStage) {\n      var codes = this.codes[shaderStage];\n      var code = '';\n      var _iterator4 = _createForOfIteratorHelper(codes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var nodeCode = _step4.value;\n          code += nodeCode.code + '\\n';\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return code;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.vertexShader + this.fragmentShader + this.computeShader;\n    }\n  }, {\n    key: \"setShaderStage\",\n    value: function setShaderStage(shaderStage) {\n      this.shaderStage = shaderStage;\n    }\n  }, {\n    key: \"getShaderStage\",\n    value: function getShaderStage() {\n      return this.shaderStage;\n    }\n  }, {\n    key: \"setBuildStage\",\n    value: function setBuildStage(buildStage) {\n      this.buildStage = buildStage;\n    }\n  }, {\n    key: \"getBuildStage\",\n    value: function getBuildStage() {\n      return this.buildStage;\n    }\n  }, {\n    key: \"buildCode\",\n    value: function buildCode() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      // setup() -> stage 1: create possible new nodes and returns an output reference node\n      // analyze()   -> stage 2: analyze nodes to possible optimization and validation\n      // generate()  -> stage 3: generate shader\n      var _iterator5 = _createForOfIteratorHelper(defaultBuildStages),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var buildStage = _step5.value;\n          this.setBuildStage(buildStage);\n          if (this.context.vertex && this.context.vertex.isNode) {\n            this.flowNodeFromShaderStage('vertex', this.context.vertex);\n          }\n          var _iterator6 = _createForOfIteratorHelper(shaderStages),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var shaderStage = _step6.value;\n              this.setShaderStage(shaderStage);\n              var flowNodes = this.flowNodes[shaderStage];\n              var _iterator7 = _createForOfIteratorHelper(flowNodes),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var node = _step7.value;\n                  if (buildStage === 'generate') {\n                    this.flowNode(node);\n                  } else {\n                    node.build(this);\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      this.setBuildStage(null);\n      this.setShaderStage(null);\n\n      // stage 4: build code for a specific output\n\n      this.buildCode();\n      this.buildUpdateNodes();\n      return this;\n    }\n  }, {\n    key: \"getNodeUniform\",\n    value: function getNodeUniform(uniformNode, type) {\n      if (type === 'float') return new FloatNodeUniform(uniformNode);\n      if (type === 'vec2') return new Vector2NodeUniform(uniformNode);\n      if (type === 'vec3') return new Vector3NodeUniform(uniformNode);\n      if (type === 'vec4') return new Vector4NodeUniform(uniformNode);\n      if (type === 'color') return new ColorNodeUniform(uniformNode);\n      if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);\n      if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);\n      throw new Error(\"Uniform \\\"\".concat(type, \"\\\" not declared.\"));\n    }\n  }, {\n    key: \"createNodeMaterial\",\n    value: function createNodeMaterial(type) {\n      return createNodeMaterialFromType(type);\n    }\n  }, {\n    key: \"format\",\n    value: function format(snippet, fromType, toType) {\n      fromType = this.getVectorType(fromType);\n      toType = this.getVectorType(toType);\n      if (fromType === toType || toType === null || this.isReference(toType)) {\n        return snippet;\n      }\n      var fromTypeLength = this.getTypeLength(fromType);\n      var toTypeLength = this.getTypeLength(toType);\n      if (fromTypeLength > 4) {\n        // fromType is matrix-like\n\n        // @TODO: ignore for now\n\n        return snippet;\n      }\n      if (toTypeLength > 4 || toTypeLength === 0) {\n        // toType is matrix-like or unknown\n\n        // @TODO: ignore for now\n\n        return snippet;\n      }\n      if (fromTypeLength === toTypeLength) {\n        return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\");\n      }\n      if (fromTypeLength > toTypeLength) {\n        return this.format(\"\".concat(snippet, \".\").concat('xyz'.slice(0, toTypeLength)), this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);\n      }\n      if (toTypeLength === 4) {\n        // toType is vec4-like\n\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec3'), \", 1.0 )\");\n      }\n      if (fromTypeLength === 2) {\n        // fromType is vec2-like and toType is vec3-like\n\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec2'), \", 0.0 )\");\n      }\n      return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\"); // fromType is float-like\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return \"// Three.js r\".concat(REVISION, \" - NodeMaterial System\\n\");\n    }\n  }]);\n  return NodeBuilder;\n}();\nexport default NodeBuilder;","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVarying","NodeVar","NodeCode","NodeKeywords","NodeCache","createNodeMaterialFromType","NodeUpdateType","defaultBuildStages","shaderStages","FloatNodeUniform","Vector2NodeUniform","Vector3NodeUniform","Vector4NodeUniform","ColorNodeUniform","Matrix3NodeUniform","Matrix4NodeUniform","REVISION","RenderTarget","NoColorSpace","LinearEncoding","sRGBEncoding","SRGBColorSpace","Color","Vector2","Vector3","Vector4","Float16BufferAttribute","stack","maxMipLevel","CubeRenderTarget","typeFromLength","Map","typeFromArray","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","isNonPaddingElementArray","Set","toFloat","value","Number","NodeBuilder","object","renderer","parser","scene","arguments","length","undefined","material","_classCallCheck","geometry","nodes","updateNodes","updateBeforeNodes","hashNodes","lightsNode","environmentNode","fogNode","toneMappingNode","vertexShader","fragmentShader","computeShader","flowNodes","vertex","fragment","compute","flowCode","uniforms","index","structs","codes","bindings","bindingsOffset","bindingsArray","attributes","bufferAttributes","varyings","vars","flow","code","chaining","tab","context","keywords","getMIPLevelAlgorithmNode","textureNode","levelNode","mul","cache","globalCache","flowsData","WeakMap","shaderStage","buildStage","_createClass","key","getRenderTarget","width","height","options","getCubeRenderTarget","size","includes","node","getBindings","concat","_toConsumableArray","setHashNode","hash","addNode","push","getHash","buildUpdateNodes","_iterator","_createForOfIteratorHelper","_step","s","n","done","updateType","getUpdateType","updateBeforeType","getUpdateBeforeType","NONE","getSelf","err","e","f","get","addChain","removeChain","lastChain","pop","Error","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","setCache","getCache","isAvailable","getVertexIndex","console","warn","getInstanceIndex","getFrontFacing","getFragCoord","isFlipY","getTexture","getTextureLevel","getConst","type","_this","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","isMatrix3","isMatrix4","elements","map","join","generateMethod","hasGeometryAttribute","name","getAttribute","_iterator2","_step2","attribute","getPropertyName","isVector","test","isMatrix","isReference","needsColorSpaceToLinear","getTextureEncodingFromMap","getTextureColorSpaceFromMap","colorSpace","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","baseType","prefix","getTypeFromArray","array","constructor","getTypeFromAttribute","dataAttribute","isInterleavedBufferAttribute","data","itemSize","has","stride","normalized","arrayType","vecType","vecNum","getVectorFromMatrix","replace","changeComponentType","newComponentType","getIntegerType","addStack","removeStack","currentStack","parent","getDataFromNode","isGlobal","nodeData","getNodeData","setNodeData","getNodeProperties","properties","outputNode","getBufferAttributeFromNode","bufferAttribute","getStructTypeFromNode","nodeStruct","structType","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","getVaryingFromNode","nodeVarying","varying","getCodeFromNode","nodeCode","addLineFlowCode","addFlowCode","addFlowTab","removeFlowTab","slice","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","set","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributesArray","getAttributes","getVaryings","getVar","getVars","snippet","_iterator3","_step3","getUniforms","getCodes","_iterator4","_step4","getShaderStage","setBuildStage","getBuildStage","buildCode","_iterator5","_step5","isNode","_iterator6","_step6","_iterator7","_step7","getNodeUniform","uniformNode","createNodeMaterial","format","fromType","toType","fromTypeLength","toTypeLength","getSignature"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVarying from './NodeVarying.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport NodeCache from './NodeCache.js';\nimport { createNodeMaterialFromType } from '../materials/NodeMaterial.js';\nimport { NodeUpdateType, defaultBuildStages, shaderStages } from './constants.js';\n\nimport {\n\tFloatNodeUniform, Vector2NodeUniform, Vector3NodeUniform, Vector4NodeUniform,\n\tColorNodeUniform, Matrix3NodeUniform, Matrix4NodeUniform\n} from '../../renderers/common/nodes/NodeUniform.js';\n\nimport { REVISION, RenderTarget, NoColorSpace, LinearEncoding, sRGBEncoding, SRGBColorSpace, Color, Vector2, Vector3, Vector4, Float16BufferAttribute } from 'three';\n\nimport { stack } from './StackNode.js';\nimport { maxMipLevel } from '../utils/MaxMipLevelNode.js';\n\nimport CubeRenderTarget from '../../renderers/common/CubeRenderTarget.js';\n\nconst typeFromLength = new Map( [\n\t[ 2, 'vec2' ],\n\t[ 3, 'vec3' ],\n\t[ 4, 'vec4' ],\n\t[ 9, 'mat3' ],\n\t[ 16, 'mat4' ]\n] );\n\nconst typeFromArray = new Map( [\n\t[ Int8Array, 'int' ],\n\t[ Int16Array, 'int' ],\n\t[ Int32Array, 'int' ],\n\t[ Uint8Array, 'uint' ],\n\t[ Uint16Array, 'uint' ],\n\t[ Uint32Array, 'uint' ],\n\t[ Float32Array, 'float' ]\n] );\n\nconst isNonPaddingElementArray = new Set( [ Int32Array, Uint32Array, Float32Array ] );\n\nconst toFloat = ( value ) => {\n\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser, scene = null, material = null ) {\n\n\t\tthis.object = object;\n\t\tthis.material = material || ( object && object.material ) || null;\n\t\tthis.geometry = ( object && object.geometry ) || null;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\t\tthis.scene = scene;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.updateBeforeNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.lightsNode = null;\n\t\tthis.environmentNode = null;\n\t\tthis.fogNode = null;\n\t\tthis.toneMappingNode = null;\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\t\tthis.computeShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '', compute: [] };\n\t\tthis.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.structs = { vertex: [], fragment: [], compute: [], index: 0 };\n\t\tthis.codes = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindings = { vertex: [], fragment: [], compute: [] };\n\t\tthis.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };\n\t\tthis.bindingsArray = null;\n\t\tthis.attributes = [];\n\t\tthis.bufferAttributes = [];\n\t\tthis.varyings = [];\n\t\tthis.vars = { vertex: [], fragment: [], compute: [] };\n\t\tthis.flow = { code: '' };\n\t\tthis.chaining = [];\n\t\tthis.stack = stack();\n\t\tthis.tab = '\\t';\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: this.material,\n\t\t\tgetMIPLevelAlgorithmNode: ( textureNode, levelNode ) => levelNode.mul( maxMipLevel( textureNode ) )\n\t\t};\n\n\t\tthis.cache = new NodeCache();\n\t\tthis.globalCache = this.cache;\n\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.buildStage = null;\n\n\t}\n\n\tgetRenderTarget( width, height, options ) {\n\n\t\treturn new RenderTarget( width, height, options );\n\n\t}\n\n\tgetCubeRenderTarget( size, options ) {\n\n\t\treturn new CubeRenderTarget( size, options );\n\n\t}\n\n\tincludes( node ) {\n\n\t\treturn this.nodes.includes( node );\n\n\t}\n\n\tgetBindings() {\n\n\t\tlet bindingsArray = this.bindingsArray;\n\n\t\tif ( bindingsArray === null ) {\n\n\t\t\tconst bindings = this.bindings;\n\n\t\t\tthis.bindingsArray = bindingsArray = ( this.material !== null ) ? [ ...bindings.vertex, ...bindings.fragment ] : bindings.compute;\n\n\t\t}\n\n\t\treturn bindingsArray;\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.includes( node ) === false ) {\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tbuildUpdateNodes() {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tconst updateType = node.getUpdateType();\n\t\t\tconst updateBeforeType = node.getUpdateBeforeType();\n\n\t\t\tif ( updateType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateNodes.push( node.getSelf() );\n\n\t\t\t}\n\n\t\t\tif ( updateBeforeType !== NodeUpdateType.NONE ) {\n\n\t\t\t\tthis.updateBeforeNodes.push( node );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tget currentNode() {\n\n\t\treturn this.chaining[ this.chaining.length - 1 ];\n\n\t}\n\n\taddChain( node ) {\n\n\t\t/*\n\t\tif ( this.chaining.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.chaining.push( node );\n\n\t}\n\n\tremoveChain( node ) {\n\n\t\tconst lastChain = this.chaining.pop();\n\n\t\tif ( lastChain !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node chaining!' );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tsetCache( cache ) {\n\n\t\tthis.cache = cache;\n\n\t}\n\n\tgetCache() {\n\n\t\treturn this.cache;\n\n\t}\n\n\tisAvailable( /*name*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\tgetVertexIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetInstanceIndex() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFrontFacing() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetFragCoord() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tisFlipY() {\n\n\t\treturn false;\n\n\t}\n\n\tgetTexture( /* texture, textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTextureLevel( /* texture, textureProperty, uvSnippet, levelSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t// @TODO: rename to .generateConst()\n\tgetConst( type, value = null ) {\n\n\t\tif ( value === null ) {\n\n\t\t\tif ( type === 'float' || type === 'int' || type === 'uint' ) value = 0;\n\t\t\telse if ( type === 'bool' ) value = false;\n\t\t\telse if ( type === 'color' ) value = new Color();\n\t\t\telse if ( type === 'vec2' ) value = new Vector2();\n\t\t\telse if ( type === 'vec3' ) value = new Vector3();\n\t\t\telse if ( type === 'vec4' ) value = new Vector4();\n\n\t\t}\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst getConst = value => this.getConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\n\n\t\t} else if ( typeLength > 4 && value && ( value.isMatrix3 || value.isMatrix4 ) ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ value.elements.map( getConst ).join( ', ' ) } )`;\n\n\t\t} else if ( typeLength > 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }()`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\thasGeometryAttribute( name ) {\n\n\t\treturn this.geometry && this.geometry.getAttribute( name ) !== undefined;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture';\n\n\t}\n\n\tneedsColorSpaceToLinear( /*texture*/ ) {\n\n\t\treturn false;\n\n\t}\n\n\t/** @deprecated, r152 */\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tconsole.warn( 'THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.' );\n\t\treturn this.getTextureColorSpaceFromMap( map ) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tgetTextureColorSpaceFromMap( map ) {\n\n\t\tlet colorSpace;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tcolorSpace = map.colorSpace;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tcolorSpace = map.texture.colorSpace;\n\n\t\t} else {\n\n\t\t\tcolorSpace = NoColorSpace;\n\n\t\t}\n\n\t\treturn colorSpace;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tif ( type === 'float' || type === 'bool' || type === 'int' || type === 'uint' ) return type;\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( length, componentType = 'float' ) {\n\n\t\tif ( length === 1 ) return componentType;\n\n\t\tconst baseType = typeFromLength.get( length );\n\t\tconst prefix = componentType === 'float' ? '' : componentType[ 0 ];\n\n\t\treturn prefix + baseType;\n\n\t}\n\n\tgetTypeFromArray( array ) {\n\n\t\treturn typeFromArray.get( array.constructor );\n\n\t}\n\n\tgetTypeFromAttribute( attribute ) {\n\n\t\tlet dataAttribute = attribute;\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) dataAttribute = attribute.data;\n\n\t\tconst array = dataAttribute.array;\n\t\tconst itemSize = isNonPaddingElementArray.has( array.constructor ) ? attribute.itemSize : dataAttribute.stride || attribute.itemSize;\n\t\tconst normalized = attribute.normalized;\n\n\t\tlet arrayType;\n\n\t\tif ( ! ( attribute instanceof Float16BufferAttribute ) && normalized !== true ) {\n\n\t\t\tarrayType = this.getTypeFromArray( array );\n\n\t\t}\n\n\t\treturn this.getTypeFromLength( itemSize, arrayType );\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\t\tif ( /mat3/.test( type ) === true ) return 9;\n\t\tif ( /mat4/.test( type ) === true ) return 16;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tchangeComponentType( type, newComponentType ) {\n\n\t\treturn this.getTypeFromLength( this.getTypeLength( type ), newComponentType );\n\n\t}\n\n\tgetIntegerType( type ) {\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tif ( componentType === 'int' || componentType === 'uint' ) return type;\n\n\t\treturn this.changeComponentType( type, 'int' );\n\n\t}\n\n\taddStack() {\n\n\t\tthis.stack = stack( this.stack );\n\n\t\treturn this.stack;\n\n\t}\n\n\tremoveStack() {\n\n\t\tconst currentStack = this.stack;\n\n\t\tthis.stack = currentStack.parent;\n\n\t\treturn currentStack;\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tconst cache = node.isGlobal( this ) ? this.globalCache : this.cache;\n\n\t\tlet nodeData = cache.getNodeData( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = {};\n\n\t\t\tcache.setNodeData( node, nodeData );\n\n\t\t}\n\n\t\tif ( nodeData[ shaderStage ] === undefined ) nodeData[ shaderStage ] = {};\n\n\t\treturn nodeData[ shaderStage ];\n\n\t}\n\n\tgetNodeProperties( node, shaderStage = 'any' ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\treturn nodeData.properties || ( nodeData.properties = { outputNode: null } );\n\n\t}\n\n\tgetBufferAttributeFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet bufferAttribute = nodeData.bufferAttribute;\n\n\t\tif ( bufferAttribute === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tbufferAttribute = new NodeAttribute( 'nodeAttribute' + index, type, node );\n\n\t\t\tthis.bufferAttributes.push( bufferAttribute );\n\n\t\t\tnodeData.bufferAttribute = bufferAttribute;\n\n\t\t}\n\n\t\treturn bufferAttribute;\n\n\t}\n\n\tgetStructTypeFromNode( node, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeStruct = nodeData.structType;\n\n\t\tif ( nodeStruct === undefined ) {\n\n\t\t\tconst index = this.structs.index ++;\n\n\t\t\tnode.name = `StructType${index}`;\n\t\t\tthis.structs[ shaderStage ].push( node );\n\n\t\t\tnodeData.structType = node;\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tgetUniformFromNode( node, type, shaderStage = this.shaderStage, name = null ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( name || ( 'nodeUniform' + index ), type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ];\n\t\t\tconst index = vars.length;\n\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryingFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, 'any' );\n\n\t\tlet nodeVarying = nodeData.varying;\n\n\t\tif ( nodeVarying === undefined ) {\n\n\t\t\tconst varyings = this.varyings;\n\t\t\tconst index = varyings.length;\n\n\t\t\tnodeVarying = new NodeVarying( 'nodeVarying' + index, type );\n\n\t\t\tvaryings.push( nodeVarying );\n\n\t\t\tnodeData.varying = nodeVarying;\n\n\t\t}\n\n\t\treturn nodeVarying;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ];\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddLineFlowCode( code ) {\n\n\t\tif ( code === '' ) return this;\n\n\t\tcode = this.tab + code;\n\n\t\tif ( ! /;\\s*$/.test( code ) ) {\n\n\t\t\tcode = code + ';\\n';\n\n\t\t}\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t\treturn this;\n\n\t}\n\n\taddFlowTab() {\n\n\t\tthis.tab += '\\t';\n\n\t\treturn this;\n\n\t}\n\n\tremoveFlowTab() {\n\n\t\tthis.tab = this.tab.slice( 0, - 1 );\n\n\t\treturn this;\n\n\t}\n\n\tgetFlowData( node/*, shaderStage*/ ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\treturn flowData;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: '',\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${ this.tab + propertyName } = ${ flowData.result };\\n`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributesArray() {\n\n\t\treturn this.attributes.concat( this.bufferAttributes );\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVaryings( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVar( type, name ) {\n\n\t\treturn `${ this.getType( type ) } ${ name }`;\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( const variable of vars ) {\n\n\t\t\tsnippet += `${ this.getVar( variable.type, variable.name ) }; `;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tfor ( const nodeCode of codes ) {\n\n\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader + this.computeShader;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetBuildStage( buildStage ) {\n\n\t\tthis.buildStage = buildStage;\n\n\t}\n\n\tgetBuildStage() {\n\n\t\treturn this.buildStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\t// setup() -> stage 1: create possible new nodes and returns an output reference node\n\t\t// analyze()   -> stage 2: analyze nodes to possible optimization and validation\n\t\t// generate()  -> stage 3: generate shader\n\n\t\tfor ( const buildStage of defaultBuildStages ) {\n\n\t\t\tthis.setBuildStage( buildStage );\n\n\t\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t\t}\n\n\t\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\t\tif ( buildStage === 'generate' ) {\n\n\t\t\t\t\t\tthis.flowNode( node );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.build( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setBuildStage( null );\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\t\tthis.buildUpdateNodes();\n\n\t\treturn this;\n\n\t}\n\n\tgetNodeUniform( uniformNode, type ) {\n\n\t\tif ( type === 'float' ) return new FloatNodeUniform( uniformNode );\n\t\tif ( type === 'vec2' ) return new Vector2NodeUniform( uniformNode );\n\t\tif ( type === 'vec3' ) return new Vector3NodeUniform( uniformNode );\n\t\tif ( type === 'vec4' ) return new Vector4NodeUniform( uniformNode );\n\t\tif ( type === 'color' ) return new ColorNodeUniform( uniformNode );\n\t\tif ( type === 'mat3' ) return new Matrix3NodeUniform( uniformNode );\n\t\tif ( type === 'mat4' ) return new Matrix4NodeUniform( uniformNode );\n\n\t\tthrow new Error( `Uniform \"${type}\" not declared.` );\n\n\t}\n\n\tcreateNodeMaterial( type ) {\n\n\t\treturn createNodeMaterialFromType( type );\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength > 4 ) { // fromType is matrix-like\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( toTypeLength > 4 || toTypeLength === 0 ) { // toType is matrix-like or unknown\n\n\t\t\t// @TODO: ignore for now\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength, this.getComponentType( fromType ) ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}