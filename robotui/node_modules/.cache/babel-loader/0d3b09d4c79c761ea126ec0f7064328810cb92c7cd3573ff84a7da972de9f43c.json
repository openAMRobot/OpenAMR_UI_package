{"ast":null,"code":"import { glslFn } from '../../code/FunctionNode.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nexport var mx_hsvtorgb = glslFn(\"vec3 mx_hsvtorgb(vec3 hsv)\\n{\\n    // Reference for this technique: Foley & van Dam\\n    float h = hsv.x; float s = hsv.y; float v = hsv.z;\\n    if (s < 0.0001f) {\\n      return vec3 (v, v, v);\\n    } else {\\n        h = 6.0f * (h - floor(h));  // expand to [0..6)\\n        int hi = int(trunc(h));\\n        float f = h - float(hi);\\n        float p = v * (1.0f-s);\\n        float q = v * (1.0f-s*f);\\n        float t = v * (1.0f-s*(1.0f-f));\\n        if (hi == 0)\\n            return vec3 (v, t, p);\\n        else if (hi == 1)\\n            return vec3 (q, v, p);\\n        else if (hi == 2)\\n            return vec3 (p, v, t);\\n        else if (hi == 3)\\n            return vec3 (p, q, v);\\n        else if (hi == 4)\\n            return vec3 (t, p, v);\\n        return vec3 (v, p, q);\\n    }\\n}\");\nexport var mx_rgbtohsv = glslFn(\"vec3 mx_rgbtohsv(vec3 c)\\n{\\n    // See Foley & van Dam\\n    float r = c.x; float g = c.y; float b = c.z;\\n    float mincomp = min (r, min(g, b));\\n    float maxcomp = max (r, max(g, b));\\n    float delta = maxcomp - mincomp;  // chroma\\n    float h, s, v;\\n    v = maxcomp;\\n    if (maxcomp > 0.0f)\\n        s = delta / maxcomp;\\n    else s = 0.0f;\\n    if (s <= 0.0f)\\n        h = 0.0f;\\n    else {\\n        if      (r >= maxcomp) h = (g-b) / delta;\\n        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;\\n        else                   h = 4.0f + (r-g) / delta;\\n        h *= (1.0f/6.0f);\\n        if (h < 0.0f)\\n            h += 1.0f;\\n    }\\n    return vec3(h, s, v);\\n}\");","map":{"version":3,"names":["glslFn","mx_hsvtorgb","mx_rgbtohsv"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js"],"sourcesContent":["import { glslFn } from '../../code/FunctionNode.js';\n\n// Original shader code from:\n// https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl\n\nexport const mx_hsvtorgb = glslFn( `vec3 mx_hsvtorgb(vec3 hsv)\n{\n    // Reference for this technique: Foley & van Dam\n    float h = hsv.x; float s = hsv.y; float v = hsv.z;\n    if (s < 0.0001f) {\n      return vec3 (v, v, v);\n    } else {\n        h = 6.0f * (h - floor(h));  // expand to [0..6)\n        int hi = int(trunc(h));\n        float f = h - float(hi);\n        float p = v * (1.0f-s);\n        float q = v * (1.0f-s*f);\n        float t = v * (1.0f-s*(1.0f-f));\n        if (hi == 0)\n            return vec3 (v, t, p);\n        else if (hi == 1)\n            return vec3 (q, v, p);\n        else if (hi == 2)\n            return vec3 (p, v, t);\n        else if (hi == 3)\n            return vec3 (p, q, v);\n        else if (hi == 4)\n            return vec3 (t, p, v);\n        return vec3 (v, p, q);\n    }\n}` );\n\nexport const mx_rgbtohsv = glslFn( `vec3 mx_rgbtohsv(vec3 c)\n{\n    // See Foley & van Dam\n    float r = c.x; float g = c.y; float b = c.z;\n    float mincomp = min (r, min(g, b));\n    float maxcomp = max (r, max(g, b));\n    float delta = maxcomp - mincomp;  // chroma\n    float h, s, v;\n    v = maxcomp;\n    if (maxcomp > 0.0f)\n        s = delta / maxcomp;\n    else s = 0.0f;\n    if (s <= 0.0f)\n        h = 0.0f;\n    else {\n        if      (r >= maxcomp) h = (g-b) / delta;\n        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;\n        else                   h = 4.0f + (r-g) / delta;\n        h *= (1.0f/6.0f);\n        if (h < 0.0f)\n            h += 1.0f;\n    }\n    return vec3(h, s, v);\n}` );\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,4BAA4B;;AAEnD;AACA;;AAEA,OAAO,IAAMC,WAAW,GAAGD,MAAM,4xBAyB9B,CAAC;AAEJ,OAAO,IAAME,WAAW,GAAGF,MAAM,yqBAuB9B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}