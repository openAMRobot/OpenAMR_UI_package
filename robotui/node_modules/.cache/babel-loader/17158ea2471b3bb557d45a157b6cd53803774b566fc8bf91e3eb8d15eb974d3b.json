{"ast":null,"code":"import _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _construct from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _toConsumableArray from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport Node, { addNodeClass } from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\nvar NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\n\nexport function addNodeElement(name, nodeElement) {\n  if (NodeElements.has(name)) throw new Error(\"Redefinition of node element \".concat(name));\n  if (typeof nodeElement !== 'function') throw new Error(\"Node element \".concat(name, \" is not a function\"));\n  NodeElements.set(name, nodeElement);\n}\nvar parseSwizzle = function parseSwizzle(props) {\n  return props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\n};\nvar shaderNodeHandler = {\n  setup: function setup(NodeClosure, params) {\n    var inputs = params.shift();\n    return NodeClosure.apply(void 0, [nodeObjects(inputs)].concat(_toConsumableArray(params)));\n  },\n  get: function get(node, prop, nodeObj) {\n    if (typeof prop === 'string' && node[prop] === undefined) {\n      if (NodeElements.has(prop)) {\n        var nodeElement = NodeElements.get(prop);\n        return function () {\n          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n            params[_key] = arguments[_key];\n          }\n          return nodeElement.apply(void 0, [nodeObj].concat(params));\n        };\n      } else if (prop === 'self') {\n        return node;\n      } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {\n        var _nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));\n        return function () {\n          for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            params[_key2] = arguments[_key2];\n          }\n          return nodeObj.assign(_nodeElement.apply(void 0, [nodeObj].concat(params)));\n        };\n      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\n        // accessing properties ( swizzle )\n\n        prop = parseSwizzle(prop);\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {\n        // set properties ( swizzle )\n\n        prop = parseSwizzle(prop.slice(3).toLowerCase());\n\n        // sort to xyzw sequence\n\n        prop = prop.split('').sort().join('');\n        return function (value) {\n          return nodeObject(new SetNode(node, prop, value));\n        };\n      } else if (prop === 'width' || prop === 'height' || prop === 'depth') {\n        // accessing property\n\n        if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';\n        return nodeObject(new SplitNode(node, prop));\n      } else if (/^\\d+$/.test(prop) === true) {\n        // accessing array\n\n        return nodeObject(new ArrayElementNode(node, new ConstNode(Number(prop), 'uint')));\n      }\n    }\n    return node[prop];\n  }\n};\nvar nodeObjectsCacheMap = new WeakMap();\nvar ShaderNodeObject = function ShaderNodeObject(obj) {\n  var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var type = getValueType(obj);\n  if (type === 'node') {\n    var _nodeObject = nodeObjectsCacheMap.get(obj);\n    if (_nodeObject === undefined) {\n      _nodeObject = new Proxy(obj, shaderNodeHandler);\n      nodeObjectsCacheMap.set(obj, _nodeObject);\n      nodeObjectsCacheMap.set(_nodeObject, _nodeObject);\n    }\n    return _nodeObject;\n  } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {\n    return nodeObject(getConstNode(obj, altType));\n  } else if (type === 'shader') {\n    return tslFn(obj);\n  }\n  return obj;\n};\nvar ShaderNodeObjects = function ShaderNodeObjects(objects) {\n  var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  for (var name in objects) {\n    objects[name] = nodeObject(objects[name], altType);\n  }\n  return objects;\n};\nvar ShaderNodeArray = function ShaderNodeArray(array) {\n  var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var len = array.length;\n  for (var i = 0; i < len; i++) {\n    array[i] = nodeObject(array[i], altType);\n  }\n  return array;\n};\nvar ShaderNodeProxy = function ShaderNodeProxy(NodeClass) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var assignNode = function assignNode(node) {\n    return nodeObject(settings !== null ? Object.assign(node, settings) : node);\n  };\n  if (scope === null) {\n    return function () {\n      for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        params[_key3] = arguments[_key3];\n      }\n      return assignNode(_construct(NodeClass, _toConsumableArray(nodeArray(params))));\n    };\n  } else if (factor !== null) {\n    factor = nodeObject(factor);\n    return function () {\n      for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        params[_key4] = arguments[_key4];\n      }\n      return assignNode(_construct(NodeClass, [scope].concat(_toConsumableArray(nodeArray(params)), [factor])));\n    };\n  } else {\n    return function () {\n      for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        params[_key5] = arguments[_key5];\n      }\n      return assignNode(_construct(NodeClass, [scope].concat(_toConsumableArray(nodeArray(params)))));\n    };\n  }\n};\nvar ShaderNodeImmutable = function ShaderNodeImmutable(NodeClass) {\n  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    params[_key6 - 1] = arguments[_key6];\n  }\n  return nodeObject(_construct(NodeClass, _toConsumableArray(nodeArray(params))));\n};\nvar ShaderCallNodeInternal = /*#__PURE__*/function (_Node) {\n  _inherits(ShaderCallNodeInternal, _Node);\n  var _super = _createSuper(ShaderCallNodeInternal);\n  function ShaderCallNodeInternal(shaderNode, inputNodes) {\n    var _this;\n    _classCallCheck(this, ShaderCallNodeInternal);\n    _this = _super.call(this);\n    _this.shaderNode = shaderNode;\n    _this.inputNodes = inputNodes;\n    return _this;\n  }\n  _createClass(ShaderCallNodeInternal, [{\n    key: \"getNodeType\",\n    value: function getNodeType(builder) {\n      var _builder$getNodePrope = builder.getNodeProperties(this),\n        outputNode = _builder$getNodePrope.outputNode;\n      return outputNode ? outputNode.getNodeType(builder) : _get(_getPrototypeOf(ShaderCallNodeInternal.prototype), \"getNodeType\", this).call(this, builder);\n    }\n  }, {\n    key: \"call\",\n    value: function call(builder) {\n      var shaderNode = this.shaderNode,\n        inputNodes = this.inputNodes;\n      var jsFunc = shaderNode.jsFunc;\n      var outputNode = inputNodes !== null ? jsFunc(nodeObjects(inputNodes), builder.stack, builder) : jsFunc(builder.stack, builder);\n      return nodeObject(outputNode);\n    }\n  }, {\n    key: \"setup\",\n    value: function setup(builder) {\n      builder.addStack();\n      builder.stack.outputNode = this.call(builder);\n      return builder.removeStack();\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(builder, output) {\n      var _builder$getNodePrope2 = builder.getNodeProperties(this),\n        outputNode = _builder$getNodePrope2.outputNode;\n      if (outputNode === null) {\n        // TSL: It's recommended to use `tslFn` in setup() pass.\n\n        return this.call(builder).build(builder, output);\n      }\n      return _get(_getPrototypeOf(ShaderCallNodeInternal.prototype), \"generate\", this).call(this, builder, output);\n    }\n  }]);\n  return ShaderCallNodeInternal;\n}(Node);\nvar ShaderNodeInternal = /*#__PURE__*/function (_Node2) {\n  _inherits(ShaderNodeInternal, _Node2);\n  var _super2 = _createSuper(ShaderNodeInternal);\n  function ShaderNodeInternal(jsFunc) {\n    var _this2;\n    _classCallCheck(this, ShaderNodeInternal);\n    _this2 = _super2.call(this);\n    _this2.jsFunc = jsFunc;\n    return _this2;\n  }\n  _createClass(ShaderNodeInternal, [{\n    key: \"call\",\n    value: function call() {\n      var inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return nodeObject(new ShaderCallNodeInternal(this, inputs));\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      return this.call();\n    }\n  }]);\n  return ShaderNodeInternal;\n}(Node);\nvar bools = [false, true];\nvar uints = [0, 1, 2, 3];\nvar ints = [-1, -2];\nvar floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\nvar boolsCacheMap = new Map();\nfor (var _i = 0, _bools = bools; _i < _bools.length; _i++) {\n  var _bool = _bools[_i];\n  boolsCacheMap.set(_bool, new ConstNode(_bool));\n}\nvar uintsCacheMap = new Map();\nfor (var _i2 = 0, _uints = uints; _i2 < _uints.length; _i2++) {\n  var _uint = _uints[_i2];\n  uintsCacheMap.set(_uint, new ConstNode(_uint, 'uint'));\n}\nvar intsCacheMap = new Map(_toConsumableArray(uintsCacheMap).map(function (el) {\n  return new ConstNode(el.value, 'int');\n}));\nfor (var _i3 = 0, _ints = ints; _i3 < _ints.length; _i3++) {\n  var _int = _ints[_i3];\n  intsCacheMap.set(_int, new ConstNode(_int, 'int'));\n}\nvar floatsCacheMap = new Map(_toConsumableArray(intsCacheMap).map(function (el) {\n  return new ConstNode(el.value);\n}));\nfor (var _i4 = 0, _floats = floats; _i4 < _floats.length; _i4++) {\n  var _float = _floats[_i4];\n  floatsCacheMap.set(_float, new ConstNode(_float));\n}\nfor (var _i5 = 0, _floats2 = floats; _i5 < _floats2.length; _i5++) {\n  var _float2 = _floats2[_i5];\n  floatsCacheMap.set(-_float2, new ConstNode(-_float2));\n}\nvar cacheMaps = {\n  bool: boolsCacheMap,\n  uint: uintsCacheMap,\n  ints: intsCacheMap,\n  float: floatsCacheMap\n};\nvar constNodesCacheMap = new Map([].concat(_toConsumableArray(boolsCacheMap), _toConsumableArray(floatsCacheMap)));\nvar getConstNode = function getConstNode(value, type) {\n  if (constNodesCacheMap.has(value)) {\n    return constNodesCacheMap.get(value);\n  } else if (value.isNode === true) {\n    return value;\n  } else {\n    return new ConstNode(value, type);\n  }\n};\nvar safeGetNodeType = function safeGetNodeType(node) {\n  try {\n    return node.getNodeType();\n  } catch (_) {\n    return undefined;\n  }\n};\nvar ConvertType = function ConvertType(type) {\n  var cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function () {\n    for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      params[_key7] = arguments[_key7];\n    }\n    if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(function (param) {\n      return typeof param !== 'object';\n    })) {\n      params = [getValueFromType.apply(void 0, [type].concat(_toConsumableArray(params)))];\n    }\n    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\n      return nodeObject(cacheMap.get(params[0]));\n    }\n    if (params.length === 1) {\n      var node = getConstNode(params[0], type);\n      if (safeGetNodeType(node) === type) return nodeObject(node);\n      return nodeObject(new ConvertNode(node, type));\n    }\n    var nodes = params.map(function (param) {\n      return getConstNode(param);\n    });\n    return nodeObject(new JoinNode(nodes, type));\n  };\n};\n\n// exports\n\n// utils\n\nexport var getConstNodeType = function getConstNodeType(value) {\n  return value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;\n};\n\n// shader node base\n\nexport function ShaderNode(jsFunc) {\n  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);\n}\nexport var nodeObject = function nodeObject(val) {\n  var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return (/* new */ShaderNodeObject(val, altType)\n  );\n};\nexport var nodeObjects = function nodeObjects(val) {\n  var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new ShaderNodeObjects(val, altType);\n};\nexport var nodeArray = function nodeArray(val) {\n  var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new ShaderNodeArray(val, altType);\n};\nexport var nodeProxy = function nodeProxy() {\n  for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    params[_key8] = arguments[_key8];\n  }\n  return _construct(ShaderNodeProxy, params);\n};\nexport var nodeImmutable = function nodeImmutable() {\n  for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    params[_key9] = arguments[_key9];\n  }\n  return _construct(ShaderNodeImmutable, params);\n};\nexport var shader = function shader(jsFunc) {\n  // @deprecated, r154\n\n  console.warn('TSL: shader() is deprecated. Use tslFn() instead.');\n  return new ShaderNode(jsFunc);\n};\nexport var tslFn = function tslFn(jsFunc) {\n  var shaderNode = new ShaderNode(jsFunc);\n  return function (inputs) {\n    return shaderNode.call(inputs);\n  };\n};\naddNodeClass('ShaderNode', ShaderNode);\n\n// types\n// @TODO: Maybe export from ConstNode.js?\n\nexport var color = new ConvertType('color');\nexport var float = new ConvertType('float', cacheMaps.float);\nexport var int = new ConvertType('int', cacheMaps.int);\nexport var uint = new ConvertType('uint', cacheMaps.uint);\nexport var bool = new ConvertType('bool', cacheMaps.bool);\nexport var vec2 = new ConvertType('vec2');\nexport var ivec2 = new ConvertType('ivec2');\nexport var uvec2 = new ConvertType('uvec2');\nexport var bvec2 = new ConvertType('bvec2');\nexport var vec3 = new ConvertType('vec3');\nexport var ivec3 = new ConvertType('ivec3');\nexport var uvec3 = new ConvertType('uvec3');\nexport var bvec3 = new ConvertType('bvec3');\nexport var vec4 = new ConvertType('vec4');\nexport var ivec4 = new ConvertType('ivec4');\nexport var uvec4 = new ConvertType('uvec4');\nexport var bvec4 = new ConvertType('bvec4');\nexport var mat3 = new ConvertType('mat3');\nexport var imat3 = new ConvertType('imat3');\nexport var umat3 = new ConvertType('umat3');\nexport var bmat3 = new ConvertType('bmat3');\nexport var mat4 = new ConvertType('mat4');\nexport var imat4 = new ConvertType('imat4');\nexport var umat4 = new ConvertType('umat4');\nexport var bmat4 = new ConvertType('bmat4');\nexport var string = function string() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return nodeObject(new ConstNode(value, 'string'));\n};\nexport var arrayBuffer = function arrayBuffer(value) {\n  return nodeObject(new ConstNode(value, 'ArrayBuffer'));\n};\naddNodeElement('color', color);\naddNodeElement('float', float);\naddNodeElement('int', int);\naddNodeElement('uint', uint);\naddNodeElement('bool', bool);\naddNodeElement('vec2', vec2);\naddNodeElement('ivec2', ivec2);\naddNodeElement('uvec2', uvec2);\naddNodeElement('bvec2', bvec2);\naddNodeElement('vec3', vec3);\naddNodeElement('ivec3', ivec3);\naddNodeElement('uvec3', uvec3);\naddNodeElement('bvec3', bvec3);\naddNodeElement('vec4', vec4);\naddNodeElement('ivec4', ivec4);\naddNodeElement('uvec4', uvec4);\naddNodeElement('bvec4', bvec4);\naddNodeElement('mat3', mat3);\naddNodeElement('imat3', imat3);\naddNodeElement('umat3', umat3);\naddNodeElement('bmat3', bmat3);\naddNodeElement('mat4', mat4);\naddNodeElement('imat4', imat4);\naddNodeElement('umat4', umat4);\naddNodeElement('bmat4', bmat4);\naddNodeElement('string', string);\naddNodeElement('arrayBuffer', arrayBuffer);\n\n// basic nodes\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\nexport var element = nodeProxy(ArrayElementNode);\nexport var convert = function convert(node, types) {\n  return nodeObject(new ConvertNode(nodeObject(node), types));\n};\nexport var split = function split(node, channels) {\n  return nodeObject(new SplitNode(nodeObject(node), channels));\n};\naddNodeElement('element', element);\naddNodeElement('convert', convert);","map":{"version":3,"names":["Node","addNodeClass","ArrayElementNode","ConvertNode","JoinNode","SplitNode","SetNode","ConstNode","getValueFromType","getValueType","NodeElements","Map","addNodeElement","name","nodeElement","has","Error","concat","set","parseSwizzle","props","replace","shaderNodeHandler","setup","NodeClosure","params","inputs","shift","apply","nodeObjects","_toConsumableArray","get","node","prop","nodeObj","undefined","_len","arguments","length","Array","_key","endsWith","slice","_len2","_key2","assign","test","nodeObject","toLowerCase","split","sort","join","value","Number","nodeObjectsCacheMap","WeakMap","ShaderNodeObject","obj","altType","type","Proxy","getConstNode","tslFn","ShaderNodeObjects","objects","ShaderNodeArray","array","len","i","ShaderNodeProxy","NodeClass","scope","factor","settings","assignNode","Object","_len3","_key3","_construct","nodeArray","_len4","_key4","_len5","_key5","ShaderNodeImmutable","_len6","_key6","ShaderCallNodeInternal","_Node","_inherits","_super","_createSuper","shaderNode","inputNodes","_this","_classCallCheck","call","_createClass","key","getNodeType","builder","_builder$getNodePrope","getNodeProperties","outputNode","_get","_getPrototypeOf","prototype","jsFunc","stack","addStack","removeStack","generate","output","_builder$getNodePrope2","build","ShaderNodeInternal","_Node2","_super2","_this2","bools","uints","ints","floats","Math","PI","boolsCacheMap","_i","_bools","bool","uintsCacheMap","_i2","_uints","uint","intsCacheMap","map","el","_i3","_ints","int","floatsCacheMap","_i4","_floats","float","_i5","_floats2","cacheMaps","constNodesCacheMap","isNode","safeGetNodeType","_","ConvertType","cacheMap","_len7","_key7","includes","every","param","nodes","getConstNodeType","nodeType","convertTo","ShaderNode","val","nodeProxy","_len8","_key8","nodeImmutable","_len9","_key9","shader","console","warn","color","vec2","ivec2","uvec2","bvec2","vec3","ivec3","uvec3","bvec3","vec4","ivec4","uvec4","bvec4","mat3","imat3","umat3","bmat3","mat4","imat4","umat4","bmat4","string","arrayBuffer","element","convert","types","channels"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js"],"sourcesContent":["import Node, { addNodeClass } from '../core/Node.js';\nimport ArrayElementNode from '../utils/ArrayElementNode.js';\nimport ConvertNode from '../utils/ConvertNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport SetNode from '../utils/SetNode.js';\nimport ConstNode from '../core/ConstNode.js';\nimport { getValueFromType, getValueType } from '../core/NodeUtils.js';\n\nconst NodeElements = new Map(); // @TODO: Currently only a few nodes are added, probably also add others\n\nexport function addNodeElement( name, nodeElement ) {\n\n\tif ( NodeElements.has( name ) ) throw new Error( `Redefinition of node element ${ name }` );\n\tif ( typeof nodeElement !== 'function' ) throw new Error( `Node element ${ name } is not a function` );\n\n\tNodeElements.set( name, nodeElement );\n\n}\n\nconst parseSwizzle = ( props ) => props.replace( /r|s/g, 'x' ).replace( /g|t/g, 'y' ).replace( /b|p/g, 'z' ).replace( /a|q/g, 'w' );\n\nconst shaderNodeHandler = {\n\n\tsetup( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( nodeObjects( inputs ), ...params );\n\n\t},\n\n\tget: function ( node, prop, nodeObj ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( NodeElements.has( prop ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop );\n\n\t\t\t\treturn ( ...params ) => nodeElement( nodeObj, ...params );\n\n\t\t\t} else if ( prop === 'self' ) {\n\n\t\t\t\treturn node;\n\n\t\t\t} else if ( prop.endsWith( 'Assign' ) && NodeElements.has( prop.slice( 0, prop.length - 'Assign'.length ) ) ) {\n\n\t\t\t\tconst nodeElement = NodeElements.get( prop.slice( 0, prop.length - 'Assign'.length ) );\n\n\t\t\t\treturn ( ...params ) => nodeObj.assign( nodeElement( nodeObj, ...params ) );\n\n\t\t\t} else if ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop );\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^set[XYZWRGBASTPQ]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// set properties ( swizzle )\n\n\t\t\t\tprop = parseSwizzle( prop.slice( 3 ).toLowerCase() );\n\n\t\t\t\t// sort to xyzw sequence\n\n\t\t\t\tprop = prop.split( '' ).sort().join( '' );\n\n\t\t\t\treturn ( value ) => nodeObject( new SetNode( node, prop, value ) );\n\n\t\t\t} else if ( prop === 'width' || prop === 'height' || prop === 'depth' ) {\n\n\t\t\t\t// accessing property\n\n\t\t\t\tif ( prop === 'width' ) prop = 'x';\n\t\t\t\telse if ( prop === 'height' ) prop = 'y';\n\t\t\t\telse if ( prop === 'depth' ) prop = 'z';\n\n\t\t\t\treturn nodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn nodeObject( new ArrayElementNode( node, new ConstNode( Number( prop ), 'uint' ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node[ prop ];\n\n\t}\n\n};\n\nconst nodeObjectsCacheMap = new WeakMap();\n\nconst ShaderNodeObject = function ( obj, altType = null ) {\n\n\tconst type = getValueType( obj );\n\n\tif ( type === 'node' ) {\n\n\t\tlet nodeObject = nodeObjectsCacheMap.get( obj );\n\n\t\tif ( nodeObject === undefined ) {\n\n\t\t\tnodeObject = new Proxy( obj, shaderNodeHandler );\n\t\t\tnodeObjectsCacheMap.set( obj, nodeObject );\n\t\t\tnodeObjectsCacheMap.set( nodeObject, nodeObject );\n\n\t\t}\n\n\t\treturn nodeObject;\n\n\t} else if ( ( altType === null && ( type === 'float' || type === 'boolean' ) ) || ( type && type !== 'shader' && type !== 'string' ) ) {\n\n\t\treturn nodeObject( getConstNode( obj, altType ) );\n\n\t} else if ( type === 'shader' ) {\n\n\t\treturn tslFn( obj );\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects, altType = null ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = nodeObject( objects[ name ], altType );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst ShaderNodeArray = function ( array, altType = null ) {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = nodeObject( array[ i ], altType );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null, settings = null ) {\n\n\tconst assignNode = ( node ) => nodeObject( settings !== null ? Object.assign( node, settings ) : node );\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( ...nodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor !== null ) {\n\n\t\tfactor = nodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ), factor ) );\n\n\t\t};\n\n\t} else {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn assignNode( new NodeClass( scope, ...nodeArray( params ) ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeImmutable = function ( NodeClass, ...params ) {\n\n\treturn nodeObject( new NodeClass( ...nodeArray( params ) ) );\n\n};\n\nclass ShaderCallNodeInternal extends Node {\n\n\tconstructor( shaderNode, inputNodes ) {\n\n\t\tsuper();\n\n\t\tthis.shaderNode = shaderNode;\n\t\tthis.inputNodes = inputNodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\treturn outputNode ? outputNode.getNodeType( builder ) : super.getNodeType( builder );\n\n\t}\n\n\tcall( builder ) {\n\n\t\tconst { shaderNode, inputNodes } = this;\n\n\t\tconst jsFunc = shaderNode.jsFunc;\n\t\tconst outputNode = inputNodes !== null ? jsFunc( nodeObjects( inputNodes ), builder.stack, builder ) : jsFunc( builder.stack, builder );\n\n\t\treturn nodeObject( outputNode );\n\n\t}\n\n\tsetup( builder ) {\n\n\t\tbuilder.addStack();\n\n\t\tbuilder.stack.outputNode = this.call( builder );\n\n\t\treturn builder.removeStack();\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst { outputNode } = builder.getNodeProperties( this );\n\n\t\tif ( outputNode === null ) {\n\n\t\t\t// TSL: It's recommended to use `tslFn` in setup() pass.\n\n\t\t\treturn this.call( builder ).build( builder, output );\n\n\t\t}\n\n\t\treturn super.generate( builder, output );\n\n\t}\n\n}\n\nclass ShaderNodeInternal extends Node {\n\n\tconstructor( jsFunc ) {\n\n\t\tsuper();\n\n\t\tthis.jsFunc = jsFunc;\n\n\t}\n\n\tcall( inputs = null ) {\n\n\t\treturn nodeObject( new ShaderCallNodeInternal( this, inputs ) );\n\n\t}\n\n\tsetup() {\n\n\t\treturn this.call();\n\n\t}\n\n}\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ - 1, - 2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2 ), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( const bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( const uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( const int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( const float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( const float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getConstNode = ( value, type ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value, type );\n\n\t}\n\n};\n\nconst safeGetNodeType = ( node ) => {\n\n\ttry {\n\n\t\treturn node.getNodeType();\n\n\t} catch ( _ ) {\n\n\t\treturn undefined;\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 || ( ! [ 'bool', 'float', 'int', 'uint' ].includes( type ) && params.every( param => typeof param !== 'object' ) ) ) {\n\n\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t}\n\n\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\treturn nodeObject( cacheMap.get( params[ 0 ] ) );\n\n\t\t}\n\n\t\tif ( params.length === 1 ) {\n\n\t\t\tconst node = getConstNode( params[ 0 ], type );\n\t\t\tif ( safeGetNodeType( node ) === type ) return nodeObject( node );\n\t\t\treturn nodeObject( new ConvertNode( node, type ) );\n\n\t\t}\n\n\t\tconst nodes = params.map( param => getConstNode( param ) );\n\t\treturn nodeObject( new JoinNode( nodes, type ) );\n\n\t};\n\n};\n\n// exports\n\n// utils\n\nexport const getConstNodeType = ( value ) => ( value !== undefined && value !== null ) ? ( value.nodeType || value.convertTo || ( typeof value === 'string' ? value : null ) ) : null;\n\n// shader node base\n\nexport function ShaderNode( jsFunc ) {\n\n\treturn new Proxy( new ShaderNodeInternal( jsFunc ), shaderNodeHandler );\n\n}\n\nexport const nodeObject = ( val, altType = null ) => /* new */ ShaderNodeObject( val, altType );\nexport const nodeObjects = ( val, altType = null ) => new ShaderNodeObjects( val, altType );\nexport const nodeArray = ( val, altType = null ) => new ShaderNodeArray( val, altType );\nexport const nodeProxy = ( ...params ) => new ShaderNodeProxy( ...params );\nexport const nodeImmutable = ( ...params ) => new ShaderNodeImmutable( ...params );\n\nexport const shader = ( jsFunc ) => { // @deprecated, r154\n\n\tconsole.warn( 'TSL: shader() is deprecated. Use tslFn() instead.' );\n\n\treturn new ShaderNode( jsFunc );\n\n};\n\nexport const tslFn = ( jsFunc ) => {\n\n\tconst shaderNode = new ShaderNode( jsFunc );\n\n\treturn ( inputs ) => shaderNode.call( inputs );\n\n};\n\naddNodeClass( 'ShaderNode', ShaderNode );\n\n// types\n// @TODO: Maybe export from ConstNode.js?\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', cacheMaps.float );\nexport const int = new ConvertType( 'int', cacheMaps.int );\nexport const uint = new ConvertType( 'uint', cacheMaps.uint );\nexport const bool = new ConvertType( 'bool', cacheMaps.bool );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat3 = new ConvertType( 'mat3' );\nexport const imat3 = new ConvertType( 'imat3' );\nexport const umat3 = new ConvertType( 'umat3' );\nexport const bmat3 = new ConvertType( 'bmat3' );\n\nexport const mat4 = new ConvertType( 'mat4' );\nexport const imat4 = new ConvertType( 'imat4' );\nexport const umat4 = new ConvertType( 'umat4' );\nexport const bmat4 = new ConvertType( 'bmat4' );\n\nexport const string = ( value = '' ) => nodeObject( new ConstNode( value, 'string' ) );\nexport const arrayBuffer = ( value ) => nodeObject( new ConstNode( value, 'ArrayBuffer' ) );\n\naddNodeElement( 'color', color );\naddNodeElement( 'float', float );\naddNodeElement( 'int', int );\naddNodeElement( 'uint', uint );\naddNodeElement( 'bool', bool );\naddNodeElement( 'vec2', vec2 );\naddNodeElement( 'ivec2', ivec2 );\naddNodeElement( 'uvec2', uvec2 );\naddNodeElement( 'bvec2', bvec2 );\naddNodeElement( 'vec3', vec3 );\naddNodeElement( 'ivec3', ivec3 );\naddNodeElement( 'uvec3', uvec3 );\naddNodeElement( 'bvec3', bvec3 );\naddNodeElement( 'vec4', vec4 );\naddNodeElement( 'ivec4', ivec4 );\naddNodeElement( 'uvec4', uvec4 );\naddNodeElement( 'bvec4', bvec4 );\naddNodeElement( 'mat3', mat3 );\naddNodeElement( 'imat3', imat3 );\naddNodeElement( 'umat3', umat3 );\naddNodeElement( 'bmat3', bmat3 );\naddNodeElement( 'mat4', mat4 );\naddNodeElement( 'imat4', imat4 );\naddNodeElement( 'umat4', umat4 );\naddNodeElement( 'bmat4', bmat4 );\naddNodeElement( 'string', string );\naddNodeElement( 'arrayBuffer', arrayBuffer );\n\n// basic nodes\n// HACK - we cannot export them from the corresponding files because of the cyclic dependency\nexport const element = nodeProxy( ArrayElementNode );\nexport const convert = ( node, types ) => nodeObject( new ConvertNode( nodeObject( node ), types ) );\nexport const split = ( node, channels ) => nodeObject( new SplitNode( nodeObject( node ), channels ) );\n\naddNodeElement( 'element', element );\naddNodeElement( 'convert', convert );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}