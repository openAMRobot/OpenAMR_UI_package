{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport Node, { addNodeClass } from './Node.js';\nimport { assign as _assign } from '../math/OperatorNode.js';\nimport { bypass } from '../core/BypassNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { cond } from '../math/CondNode.js';\nimport { loop as _loop } from '../utils/LoopNode.js';\nimport { ShaderNode, nodeProxy } from '../shadernode/ShaderNode.js';\nvar StackNode = /*#__PURE__*/function (_Node) {\n  _inherits(StackNode, _Node);\n  var _super = _createSuper(StackNode);\n  function StackNode() {\n    var _this;\n    var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, StackNode);\n    _this = _super.call(this);\n    _this.nodes = [];\n    _this.outputNode = null;\n    _this.parent = parent;\n    _this._currentCond = null;\n    _this.isStackNode = true;\n    return _this;\n  }\n  _createClass(StackNode, [{\n    key: \"getNodeType\",\n    value: function getNodeType(builder) {\n      return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';\n    }\n  }, {\n    key: \"add\",\n    value: function add(node) {\n      this.nodes.push(bypass(expression(), node));\n      return this;\n    }\n  }, {\n    key: \"if\",\n    value: function _if(boolNode, method) {\n      var methodNode = new ShaderNode(method);\n      this._currentCond = cond(boolNode, methodNode);\n      return this.add(this._currentCond);\n    }\n  }, {\n    key: \"elseif\",\n    value: function elseif(boolNode, method) {\n      var methodNode = new ShaderNode(method);\n      var ifNode = cond(boolNode, methodNode);\n      this._currentCond.elseNode = ifNode;\n      this._currentCond = ifNode;\n      return this;\n    }\n  }, {\n    key: \"else\",\n    value: function _else(method) {\n      this._currentCond.elseNode = new ShaderNode(method);\n      return this;\n    }\n  }, {\n    key: \"assign\",\n    value: function assign(targetNode, sourceValue) {\n      return this.add(_assign(targetNode, sourceValue));\n    }\n  }, {\n    key: \"loop\",\n    value: function loop() {\n      return this.add(_loop.apply(void 0, arguments));\n    }\n  }, {\n    key: \"build\",\n    value: function build(builder) {\n      var _this$outputNode, _get2;\n      var _iterator = _createForOfIteratorHelper(this.nodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var node = _step.value;\n          node.build(builder, 'void');\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        params[_key - 1] = arguments[_key];\n      }\n      return this.outputNode ? (_this$outputNode = this.outputNode).build.apply(_this$outputNode, [builder].concat(params)) : (_get2 = _get(_getPrototypeOf(StackNode.prototype), \"build\", this)).call.apply(_get2, [this, builder].concat(params));\n    }\n  }]);\n  return StackNode;\n}(Node);\nexport default StackNode;\nexport var stack = nodeProxy(StackNode);\naddNodeClass('StackNode', StackNode);","map":{"version":3,"names":["Node","addNodeClass","assign","bypass","expression","cond","loop","ShaderNode","nodeProxy","StackNode","_Node","_inherits","_super","_createSuper","_this","parent","arguments","length","undefined","_classCallCheck","call","nodes","outputNode","_currentCond","isStackNode","_createClass","key","value","getNodeType","builder","add","node","push","_if","boolNode","method","methodNode","elseif","ifNode","elseNode","_else","targetNode","sourceValue","apply","build","_this$outputNode","_get2","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","_len","params","Array","_key","concat","_get","_getPrototypeOf","prototype","stack"],"sources":["/home/darkadius/ros2_ws/src/BotshareWIP/ROS2/robotui/node_modules/three/examples/jsm/nodes/core/StackNode.js"],"sourcesContent":["import Node, { addNodeClass } from './Node.js';\nimport { assign } from '../math/OperatorNode.js';\nimport { bypass } from '../core/BypassNode.js';\nimport { expression } from '../code/ExpressionNode.js';\nimport { cond } from '../math/CondNode.js';\nimport { loop } from '../utils/LoopNode.js';\nimport { ShaderNode, nodeProxy } from '../shadernode/ShaderNode.js';\n\nclass StackNode extends Node {\n\n\tconstructor( parent = null ) {\n\n\t\tsuper();\n\n\t\tthis.nodes = [];\n\t\tthis.outputNode = null;\n\n\t\tthis.parent = parent;\n\n\t\tthis._currentCond = null;\n\n\t\tthis.isStackNode = true;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.outputNode ? this.outputNode.getNodeType( builder ) : 'void';\n\n\t}\n\n\tadd( node ) {\n\n\t\tthis.nodes.push( bypass( expression(), node ) );\n\n\t\treturn this;\n\n\t}\n\n\tif( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tthis._currentCond = cond( boolNode, methodNode );\n\n\t\treturn this.add( this._currentCond );\n\n\t}\n\n\telseif( boolNode, method ) {\n\n\t\tconst methodNode = new ShaderNode( method );\n\t\tconst ifNode = cond( boolNode, methodNode );\n\n\t\tthis._currentCond.elseNode = ifNode;\n\t\tthis._currentCond = ifNode;\n\n\t\treturn this;\n\n\t}\n\n\telse( method ) {\n\n\t\tthis._currentCond.elseNode = new ShaderNode( method );\n\n\t\treturn this;\n\n\t}\n\n\tassign( targetNode, sourceValue ) {\n\n\t\treturn this.add( assign( targetNode, sourceValue ) );\n\n\t}\n\n\tloop( ...params ) {\n\n\t\treturn this.add( loop( ...params ) );\n\n\t}\n\n\tbuild( builder, ...params ) {\n\n\t\tfor ( const node of this.nodes ) {\n\n\t\t\tnode.build( builder, 'void' );\n\n\t\t}\n\n\t\treturn this.outputNode ? this.outputNode.build( builder, ...params ) : super.build( builder, ...params );\n\n\t}\n\n}\n\nexport default StackNode;\n\nexport const stack = nodeProxy( StackNode );\n\naddNodeClass( 'StackNode', StackNode );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}